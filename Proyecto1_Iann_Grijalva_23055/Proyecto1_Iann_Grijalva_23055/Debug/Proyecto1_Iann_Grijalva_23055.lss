
AVRASM ver. 2.2.8  C:\Users\ianng\Desktop\micros\micros\Proyecto1_Iann_Grijalva_23055\Proyecto1_Iann_Grijalva_23055\main.asm Thu Mar 20 18:02:13 2025

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328Pdef.inc'
C:\Users\ianng\Desktop\micros\micros\Proyecto1_Iann_Grijalva_23055\Proyecto1_Iann_Grijalva_23055\main.asm(14): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328pdef.inc'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328Pdef.inc'
C:\Users\ianng\Desktop\micros\micros\Proyecto1_Iann_Grijalva_23055\Proyecto1_Iann_Grijalva_23055\main.asm(14): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328pdef.inc'
                                 
                                 ;************************
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega328P.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m328Pdef.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega328P
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega328P
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M328PDEF_INC_
                                 #define _M328PDEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega328P
                                 #pragma AVRPART ADMIN PART_NAME ATmega328P
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x95
                                 .equ	SIGNATURE_002	= 0x0f
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                                 .equ	PRR	= 0x64	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	SPMCSR	= 0x37
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	SMCR	= 0x33
                                 .equ	ACSR	= 0x30
                                 .equ	SPDR	= 0x2e
                                 .equ	SPSR	= 0x2d
                                 .equ	SPCR	= 0x2c
                                 .equ	GPIOR2	= 0x2b
                                 .equ	GPIOR1	= 0x2a
                                 .equ	OCR0B	= 0x28
                                 .equ	OCR0A	= 0x27
                                 .equ	TCNT0	= 0x26
                                 .equ	TCCR0B	= 0x25
                                 .equ	TCCR0A	= 0x24
                                 .equ	GTCCR	= 0x23
                                 .equ	EEARH	= 0x22
                                 .equ	EEARL	= 0x21
                                 .equ	EEDR	= 0x20
                                 .equ	EECR	= 0x1f
                                 .equ	GPIOR0	= 0x1e
                                 .equ	EIMSK	= 0x1d
                                 .equ	EIFR	= 0x1c
                                 .equ	PCIFR	= 0x1b
                                 .equ	TIFR2	= 0x17
                                 .equ	TIFR1	= 0x16
                                 .equ	TIFR0	= 0x15
                                 .equ	PORTD	= 0x0b
                                 .equ	DDRD	= 0x0a
                                 .equ	PIND	= 0x09
                                 .equ	PORTC	= 0x08
                                 .equ	DDRC	= 0x07
                                 .equ	PINC	= 0x06
                                 .equ	PORTB	= 0x05
                                 .equ	DDRB	= 0x04
                                 .equ	PINB	= 0x03
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCPHA0	= UCSZ00	; For compatibility
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	UDORD0	= UCSZ01	; For compatibility
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL00	= 6	; USART Mode Select
                                 .equ	UMSEL0	= UMSEL00	; For compatibility
                                 .equ	UMSEL01	= 7	; USART Mode Select
                                 .equ	UMSEL1	= UMSEL01	; For compatibility
                                 
                                 ; UBRR0H - USART Baud Rate Register High Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	_UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	_UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWAMR - TWI (Slave) Address Mask Register
                                 .equ	TWAM0	= 1	; 
                                 .equ	TWAMR0	= TWAM0	; For compatibility
                                 .equ	TWAM1	= 2	; 
                                 .equ	TWAMR1	= TWAM1	; For compatibility
                                 .equ	TWAM2	= 3	; 
                                 .equ	TWAMR2	= TWAM2	; For compatibility
                                 .equ	TWAM3	= 4	; 
                                 .equ	TWAMR3	= TWAM3	; For compatibility
                                 .equ	TWAM4	= 5	; 
                                 .equ	TWAMR4	= TWAM4	; For compatibility
                                 .equ	TWAM5	= 6	; 
                                 .equ	TWAMR5	= TWAM5	; For compatibility
                                 .equ	TWAM6	= 7	; 
                                 .equ	TWAMR6	= TWAM6	; For compatibility
                                 
                                 ; TWBR - TWI Bit Rate register
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	TWS7	= 7	; TWI Status
                                 
                                 ; TWDR - TWI Data register
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK1 - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1A	= 1	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	OCIE1B	= 2	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; TIFR1 - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode
                                 .equ	WGM11	= 1	; Waveform Generation Mode
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1B	= 6	; 
                                 .equ	FOC1A	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	TOIE2A	= TOIE2	; For compatibility
                                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                                 
                                 ; TCCR2A - Timer/Counter2 Control Register A
                                 .equ	WGM20	= 0	; Waveform Genration Mode
                                 .equ	WGM21	= 1	; Waveform Genration Mode
                                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                                 
                                 ; TCCR2B - Timer/Counter2 Control Register B
                                 .equ	CS20	= 0	; Clock Select bit 0
                                 .equ	CS21	= 1	; Clock Select bit 1
                                 .equ	CS22	= 2	; Clock Select bit 2
                                 .equ	WGM22	= 3	; Waveform Generation Mode
                                 .equ	FOC2B	= 6	; Force Output Compare B
                                 .equ	FOC2A	= 7	; Force Output Compare A
                                 
                                 ; TCNT2 - Timer/Counter2
                                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                                 
                                 ; OCR2A - Timer/Counter2 Output Compare Register A
                                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; OCR2B - Timer/Counter2 Output Compare Register B
                                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                                 .equ	EXCLK	= 6	; Enable External Clock Input
                                 
                                 ; GTCCR - General Timer Counter Control register
                                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                                 .equ	PSR2	= PSRASY	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register A
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCSRB - The ADC Control and Status register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                                 .equ	ACME	= 6	; 
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; DIDR0 - Digital Input Disable Register
                                 .equ	ADC0D	= 0	; 
                                 .equ	ADC1D	= 1	; 
                                 .equ	ADC2D	= 2	; 
                                 .equ	ADC3D	= 3	; 
                                 .equ	ADC4D	= 4	; 
                                 .equ	ADC5D	= 5	; 
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR1 - Digital Input Disable Register 1
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; 
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare A
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A_0	= 0	; 
                                 .equ	OCR0A_1	= 1	; 
                                 .equ	OCR0A_2	= 2	; 
                                 .equ	OCR0A_3	= 3	; 
                                 .equ	OCR0A_4	= 4	; 
                                 .equ	OCR0A_5	= 5	; 
                                 .equ	OCR0A_6	= 6	; 
                                 .equ	OCR0A_7	= 7	; 
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0B_0	= 0	; 
                                 .equ	OCR0B_1	= 1	; 
                                 .equ	OCR0B_2	= 2	; 
                                 .equ	OCR0B_3	= 3	; 
                                 .equ	OCR0B_4	= 4	; 
                                 .equ	OCR0B_5	= 5	; 
                                 .equ	OCR0B_6	= 6	; 
                                 .equ	OCR0B_7	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 ;.equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSRSYNC	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register
                                 .equ	ISC00	= 0	; External Interrupt Sense Control 0 Bit 0
                                 .equ	ISC01	= 1	; External Interrupt Sense Control 0 Bit 1
                                 .equ	ISC10	= 2	; External Interrupt Sense Control 1 Bit 0
                                 .equ	ISC11	= 3	; External Interrupt Sense Control 1 Bit 1
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                                 
                                 ; PCMSK2 - Pin Change Mask Register 2
                                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                                 
                                 ; PCMSK1 - Pin Change Mask Register 1
                                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                                 
                                 ; PCMSK0 - Pin Change Mask Register 0
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCSR - Watchdog Timer Control Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; CLKPR - Clock Prescale Register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                                 
                                 ; SPMCSR - Store Program Memory Control and Status Register
                                 .equ    SELFPRGEN = 0; Added for backwards compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read-While-Write section read enable
                                 .equ    SIGRD   = 5 ; Signature Row Read
                                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; 
                                 .equ	IVSEL	= 1	; 
                                 .equ	PUD	= 4	; 
                                 .equ	BODSE	= 5	; BOD Sleep Enable
                                 .equ	BODS	= 6	; BOD Sleep
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	EXTREF	= EXTRF	; For compatibility
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0	; Sleep Enable
                                 .equ	SM0	= 1	; Sleep Mode Select Bit 0
                                 .equ	SM1	= 2	; Sleep Mode Select Bit 1
                                 .equ	SM2	= 3	; Sleep Mode Select Bit 2
                                 
                                 ; GPIOR2 - General Purpose I/O Register 2
                                 .equ	GPIOR20	= 0	; 
                                 .equ	GPIOR21	= 1	; 
                                 .equ	GPIOR22	= 2	; 
                                 .equ	GPIOR23	= 3	; 
                                 .equ	GPIOR24	= 4	; 
                                 .equ	GPIOR25	= 5	; 
                                 .equ	GPIOR26	= 6	; 
                                 .equ	GPIOR27	= 7	; 
                                 
                                 ; GPIOR1 - General Purpose I/O Register 1
                                 .equ	GPIOR10	= 0	; 
                                 .equ	GPIOR11	= 1	; 
                                 .equ	GPIOR12	= 2	; 
                                 .equ	GPIOR13	= 3	; 
                                 .equ	GPIOR14	= 4	; 
                                 .equ	GPIOR15	= 5	; 
                                 .equ	GPIOR16	= 6	; 
                                 .equ	GPIOR17	= 7	; 
                                 
                                 ; GPIOR0 - General Purpose I/O Register 0
                                 .equ	GPIOR00	= 0	; 
                                 .equ	GPIOR01	= 1	; 
                                 .equ	GPIOR02	= 2	; 
                                 .equ	GPIOR03	= 3	; 
                                 .equ	GPIOR04	= 4	; 
                                 .equ	GPIOR05	= 5	; 
                                 .equ	GPIOR06	= 6	; 
                                 .equ	GPIOR07	= 7	; 
                                 
                                 ; PRR - Power Reduction Register
                                 .equ	PRADC	= 0	; Power Reduction ADC
                                 .equ	PRUSART0	= 1	; Power Reduction USART
                                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                                 .equ	PRTWI	= 7	; Power Reduction TWI
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEARL - EEPROM Address Register Low Byte
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                                 
                                 ; EEARH - EEPROM Address Register High Byte
                                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEPE	= 1	; EEPROM Write Enable
                                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Clock output
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select reset vector
                                 .equ	BOOTSZ0	= 1	; Select boot size
                                 .equ	BOOTSZ1	= 2	; Select boot size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog Timer Always On
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	DWEN	= 6	; debugWIRE Enable
                                 .equ	RSTDISBL	= 7	; External reset disable
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 2048
                                 .equ	RAMEND	= 0x08ff
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x03ff
                                 .equ	EEPROMEND	= 0x03ff
                                 .equ	EEADRBITS	= 10
                                 #pragma AVRPART MEMORY PROG_FLASH 32768
                                 #pragma AVRPART MEMORY EEPROM 1024
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 2048
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x3800
                                 .equ	NRWW_STOP_ADDR	= 0x3fff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x37ff
                                 .equ	PAGESIZE	= 64
                                 .equ	FIRSTBOOTSTART	= 0x3f00
                                 .equ	SECONDBOOTSTART	= 0x3e00
                                 .equ	THIRDBOOTSTART	= 0x3c00
                                 .equ	FOURTHBOOTSTART	= 0x3800
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	PCI0addr	= 0x0006	; Pin Change Interrupt Request 0
                                 .equ	PCI1addr	= 0x0008	; Pin Change Interrupt Request 0
                                 .equ	PCI2addr	= 0x000a	; Pin Change Interrupt Request 1
                                 .equ	WDTaddr	= 0x000c	; Watchdog Time-out Interrupt
                                 .equ	OC2Aaddr	= 0x000e	; Timer/Counter2 Compare Match A
                                 .equ	OC2Baddr	= 0x0010	; Timer/Counter2 Compare Match A
                                 .equ	OVF2addr	= 0x0012	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0014	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0016	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x0018	; Timer/Counter1 Compare Match B
                                 .equ	OVF1addr	= 0x001a	; Timer/Counter1 Overflow
                                 .equ	OC0Aaddr	= 0x001c	; TimerCounter0 Compare Match A
                                 .equ	OC0Baddr	= 0x001e	; TimerCounter0 Compare Match B
                                 .equ	OVF0addr	= 0x0020	; Timer/Couner0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXCaddr	= 0x0024	; USART Rx Complete
                                 .equ	UDREaddr	= 0x0026	; USART, Data Register Empty
                                 .equ	UTXCaddr	= 0x0028	; USART Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	TWIaddr	= 0x0030	; Two-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0032	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 52	; size in words
                                 
                                 #endif  /* _M328PDEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; Universidad del Valle de Guatemala
                                 ; IE2023: Programacin de Microcontroladores
                                 ; Reloj Digital 24 horas con alrma
                                 ;
                                 ; Descripcin: Reloj 24 horas con modos de fecha y tambin con alarma programable
                                 ;              
                                 ;
                                 ; Hardware: ATMega328P
                                 ;************************
                                 
                                 
                                 
                                 .include "m328pdef.inc"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega328P.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m328Pdef.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega328P
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega328P
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M328PDEF_INC_
                                 #endif  /* _M328PDEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; definicin de pines para displays
                                 .equ DISPLAY_UNIDADES = PC5     ; Unidades minutos (reloj) o da (fecha)
                                 .equ DISPLAY_DECENAS = PC4      ; Decenas minutos (reloj) o da (fecha)
                                 .equ DISPLAY_UNIDADES_SUPERIOR = PC3  ; Unidades horas (reloj) o mes (fecha)
                                 .equ DISPLAY_DECENAS_SUPERIOR = PC2   ; Decenas horas (reloj) o mes (fecha)
                                 .equ LED_INDICADOR = PC1        ; LED indicador segundos/parpadeo
                                 .equ PIN_ALARMA = PC0           ; Pin para el sonido de alarma (cambiado de PD7)
                                 .equ LED_ALARMA = PB5           ; LED indicador de alarma activa (cambiado a PB5)
                                 
                                 ; definicin de pines de botones
                                 .equ BTN_INC_INFERIOR = PB0     ; Incremento minutos/da y apagar alarma
                                 .equ BTN_DEC_INFERIOR = PB3     ; Decremento minutos/da y desprogramar alarma
                                 .equ BTN_INC_SUPERIOR = PB4     ; Incremento horas/mes y cambio de modo
                                 .equ BTN_DEC_SUPERIOR = PB1     ; Decremento horas/mes y configurar alarma
                                 .equ BTN_MODO = PB2             ; Cambio entre modo normal y edicin, confirmar alarma
                                 
                                 ; estados del sistema
                                 .equ ESTADO_RELOJ = 0           ; Mostrando reloj (hora) sin editar
                                 .equ ESTADO_EDICION_RELOJ = 1   ; Editando reloj (hora)
                                 .equ ESTADO_FECHA = 2           ; Mostrando fecha sin editar
                                 .equ ESTADO_EDICION_FECHA = 3   ; Editando fecha
                                 .equ ESTADO_EDICION_ALARMA = 4  ; Editando alarma
                                 
                                 ; variables en SRAM
                                 .dseg
                                 .org 0x0100
000100                           tabla_digitos: .byte 10        ; tabla de conversin a 7 segmentos
00010a                           dias_por_mes: .byte 12         ; tabla con das por mes (1-12)
                                 
                                 ; variables para el reloj
000116                           contador_unidades_min: .byte 1  ; unidades de minutos (0-9)
000117                           contador_decenas_min: .byte 1   ; decenas de minutos (0-5)
000118                           contador_unidades_hora: .byte 1 ; unidades de hora (0-9)
000119                           contador_decenas_hora: .byte 1  ; decenas de hora (0-2)
00011a                           contador_minutos: .byte 1       ; contador total de minutos (0-59)
00011b                           contador_horas: .byte 1         ; contador total de horas (0-23)
                                 
                                 ; variables para la fecha
00011c                           contador_unidades_dia: .byte 1  ; unidades de da (0-9)
00011d                           contador_decenas_dia: .byte 1   ; decenas de da (0-3)
00011e                           contador_unidades_mes: .byte 1  ; unidades de mes (0-9)
00011f                           contador_decenas_mes: .byte 1   ; decenas de mes (0-1)
000120                           contador_dia: .byte 1           ; contador total de da (1-31)
000121                           contador_mes: .byte 1           ; contador total de mes (1-12)
                                 
                                 ; variables para la alarma
000122                           alarma_unidades_min: .byte 1    ; unidades de minutos para alarma (0-9)
000123                           alarma_decenas_min: .byte 1     ; decenas de minutos para alarma (0-5)
000124                           alarma_unidades_hora: .byte 1   ; unidades de hora para alarma (0-9)
000125                           alarma_decenas_hora: .byte 1    ; decenas de hora para alarma (0-2)
000126                           alarma_minutos: .byte 1         ; valor total de minutos para alarma (0-59)
000127                           alarma_horas: .byte 1           ; valor total de horas para alarma (0-23)
000128                           alarma_activa: .byte 1          ; estado de la alarma (0 = desactivada, 1 = activada)
000129                           alarma_sonando: .byte 1         ; indica si la alarma est sonando (0 = no, 1 = s)
00012a                           contador_alarma: .byte 1        ; contador para la duracin de la alarma (max 30 segundos)
                                 
                                 ; variables generales
00012b                           contador_timer: .byte 1        ; contador para la interrupcin del timer
00012c                           contador_segundos: .byte 1     ; contador de segundos (0-59)
00012d                           estado_led: .byte 1            ; estado del LED (0 = apagado, 1 = encendido)
00012e                           contador_parpadeo: .byte 1     ; contador para parpadeo del LED
00012f                           btn_estado_previo: .byte 5     ; estado previo de los 5 botones
000134                           estado_sistema: .byte 1        ; estado actual del sistema
                                 
                                 .cseg
                                 .org 0x0000
000000 c020                          rjmp RESET                 ; vector de reset
                                 
                                 .org OVF0addr
000020 c466                          rjmp TIMER0_OVF            ; vector de interrupcin del Timer0
                                 
                                 RESET:
                                     ; configuracin de la pila
000021 e008                          ldi r16, HIGH(RAMEND)
000022 bf0e                          out SPH, r16
000023 ef0f                          ldi r16, LOW(RAMEND)
000024 bf0d                          out SPL, r16
                                 
                                     ; inicializacin de puertos
                                     ; PC5-PC0 como salidas (displays, LEDs indicadores y alarma)
000025 e30f                          ldi r16, (1<<DISPLAY_UNIDADES)|(1<<DISPLAY_DECENAS)|(1<<DISPLAY_UNIDADES_SUPERIOR)|(1<<DISPLAY_DECENAS_SUPERIOR)|(1<<LED_INDICADOR)|(1<<PIN_ALARMA)
000026 b907                          out DDRC, r16
                                 
                                     ; puerto D (PD0-PD6) como salidas (segmentos a-g)
000027 e70f                          ldi r16, 0b01111111        ; PD0-PD6 como salidas
000028 b90a                          out DDRD, r16
                                     
                                     ; Configurar PB5 como salida para LED de alarma (mantener PB0-PB4 como entradas)
000029 b104                          in r16, DDRB              ; leer valor actual de DDRB
00002a 6200                          ori r16, (1<<LED_ALARMA)  ; Establecer solo el bit PB5 como salida
00002b b904                          out DDRB, r16             ; escribir de nuevo el registro
                                     
                                     ; inicializar PC0 (alarma) en estado bajo
00002c 9840                          cbi PORTC, PIN_ALARMA
                                     
                                     ; inicializar PB5 (LED de alarma) en estado bajo
00002d 982d                          cbi PORTB, LED_ALARMA
                                     
                                     ; configurar pines de botones como entradas con pull-up
00002e e000                          ldi r16, 0                ; limpiar r16
00002f 610f                          ori r16, (1<<BTN_INC_INFERIOR)|(1<<BTN_DEC_INFERIOR)|(1<<BTN_INC_SUPERIOR)|(1<<BTN_DEC_SUPERIOR)|(1<<BTN_MODO)
000030 b905                          out PORTB, r16            ; activar resistencias pull-up solo para los botones
                                     
                                     ; configurar pines de botones como entradas con pull-up (despus de configurar PB5)
                                     ; Nota: ya configuramos DDRB en el paso anterior para que PB5 sea salida y PB0-PB4 sean entradas
                                 
                                     ; inicializacin de contadores de reloj (00:00 por defecto)
000031 e000                          ldi r16, 0
000032 9300 0116                     sts contador_unidades_min, r16
000034 9300 0117                     sts contador_decenas_min, r16
000036 9300 0118                     sts contador_unidades_hora, r16
000038 9300 0119                     sts contador_decenas_hora, r16
00003a 9300 011a                     sts contador_minutos, r16
00003c 9300 011b                     sts contador_horas, r16
                                     
                                     ; inicializacin de contadores de fecha (01/01 por defecto)
00003e e001                          ldi r16, 1
00003f 9300 011c                     sts contador_unidades_dia, r16
000041 e000                          ldi r16, 0
000042 9300 011d                     sts contador_decenas_dia, r16
000044 e001                          ldi r16, 1
000045 9300 011e                     sts contador_unidades_mes, r16
000047 e000                          ldi r16, 0
000048 9300 011f                     sts contador_decenas_mes, r16
00004a e001                          ldi r16, 1
00004b 9300 0120                     sts contador_dia, r16
00004d 9300 0121                     sts contador_mes, r16
                                     
                                     ; inicializacin de variables de alarma
00004f e000                          ldi r16, 0
000050 9300 0122                     sts alarma_unidades_min, r16
000052 9300 0123                     sts alarma_decenas_min, r16
000054 9300 0124                     sts alarma_unidades_hora, r16
000056 9300 0125                     sts alarma_decenas_hora, r16
000058 9300 0126                     sts alarma_minutos, r16
00005a 9300 0127                     sts alarma_horas, r16
00005c 9300 0128                     sts alarma_activa, r16      ; alarma desactivada por defecto
00005e 9300 0129                     sts alarma_sonando, r16     ; alarma no sonando por defecto
000060 9300 012a                     sts contador_alarma, r16    ; contador de duracin en 0
                                     
                                     ; LED de alarma inicialmente apagado
000062 9845                          cbi PORTC, LED_ALARMA
                                     
                                     ; inicializar otros contadores
000063 e000                          ldi r16, 0
000064 9300 012b                     sts contador_timer, r16
000066 9300 012c                     sts contador_segundos, r16
000068 9300 012e                     sts contador_parpadeo, r16
                                     
                                     ; inicializar estado del sistema
00006a e000                          ldi r16, ESTADO_RELOJ
00006b 9300 0134                     sts estado_sistema, r16
                                     
                                     ; iniciar con el LED encendido
00006d e001                          ldi r16, 1
00006e 9300 012d                     sts estado_led, r16
                                     
                                     ; inicializar estados previos de botones 
000070 e001                          ldi r16, 1                  ; botones liberados (con pull-up = 1)
000071 9300 012f                     sts btn_estado_previo+0, r16  ; botn incremento inferior
000073 9300 0130                     sts btn_estado_previo+1, r16  ; botn decremento inferior
000075 9300 0131                     sts btn_estado_previo+2, r16  ; botn incremento superior
000077 9300 0132                     sts btn_estado_previo+3, r16  ; botn decremento superior
000079 9300 0133                     sts btn_estado_previo+4, r16  ; botn cambio de modo
                                 
                                     ; inicializacin de la tabla de dgitos
00007b d344                          rcall INICIAR_TABLA_DIGITOS
                                     
                                     ; inicializacin de tabla de das por mes
00007c d26e                          rcall INICIAR_TABLA_DIAS
                                 
                                     ; configuracin del Timer0
00007d e000                          ldi r16, 0                   ; asegurar que el Timer0 est apagado inicialmente
00007e bd04                          out TCCR0A, r16
00007f e005                          ldi r16, (1<<CS02)|(1<<CS00) ; preescalado 1024
000080 bd05                          out TCCR0B, r16
000081 e001                          ldi r16, (1<<TOIE0)          ; habilitar interrupcin por desbordamiento
000082 9300 006e                     sts TIMSK0, r16
                                 
                                     ; habilitar interrupciones globales
000084 9478                          sei
                                 
                                 MAIN_LOOP:
                                     ; verificar si la alarma est sonando y manejarla
000085 d00c                          rcall VERIFICAR_ALARMA_SONANDO
                                     
                                     ; mostrar los dgitos en los displays (multiplexado) segn el modo actual
000086 d350                          rcall MOSTRAR_DISPLAYS
                                     
                                     ; verificar botn para cambiar entre modo reloj y fecha
000087 d099                          rcall VERIFICAR_CAMBIO_MODO_DISPLAY
                                     
                                     ; verificar botn de modo edicin/confirmar
000088 d0c2                          rcall VERIFICAR_MODO_EDICION
                                     
                                     ; verificar botones de alarma (en modo reloj normal)
000089 d018                          rcall VERIFICAR_BOTONES_ALARMA
                                     
                                     ; verificar botones de ajuste segn el estado actual
00008a 9100 0134                     lds r16, estado_sistema
00008c 3000                          cpi r16, ESTADO_RELOJ
00008d f019                          breq MAIN_CONTINUE         ; si estamos en modo reloj normal, no verificar botones de edicin
                                     
00008e 3002                          cpi r16, ESTADO_FECHA
00008f f009                          breq MAIN_CONTINUE         ; si estamos en modo fecha normal, no verificar botones de edicin
                                     
                                     ; en modo edicin (reloj, fecha o alarma), verificar botones para ajustar
000090 d0f8                          rcall VERIFICAR_BOTONES
                                     
                                 MAIN_CONTINUE:
000091 cff3                          rjmp MAIN_LOOP
                                 
                                 ; verificar si la alarma est sonando y manejarla
                                 VERIFICAR_ALARMA_SONANDO:
000092 930f                          push r16
000093 931f                          push r17
                                     
                                     ; verificar si la alarma est sonando
000094 9100 0129                     lds r16, alarma_sonando
000096 3001                          cpi r16, 1
000097 f439                          brne ALARMA_NO_SONANDO
                                     
                                     ; la alarma est sonando, verificar si se super el tiempo mximo (30 seg)
000098 9100 012a                     lds r16, contador_alarma
00009a 310e                          cpi r16, 30
00009b f010                          brlo ALARMA_CONTINUA_SONANDO
                                     
                                     ; se super el tiempo mximo, apagar la alarma
00009c d05a                          rcall APAGAR_ALARMA
00009d c001                          rjmp ALARMA_NO_SONANDO
                                     
                                 ALARMA_CONTINUA_SONANDO:
                                     ; hacer que la alarma suene continuamente (mantener en estado alto)
00009e 9a40                          sbi PORTC, PIN_ALARMA       ; mantener la alarma encendida en PC0
                                     
                                 ALARMA_NO_SONANDO:
00009f 911f                          pop r17
0000a0 910f                          pop r16
0000a1 9508                          ret
                                 
                                 ; verificar botones para manejar la alarma en modo reloj normal
                                 VERIFICAR_BOTONES_ALARMA:
0000a2 930f                          push r16
0000a3 931f                          push r17
                                     
                                     ; solo verificar en modo reloj normal
0000a4 9100 0134                     lds r16, estado_sistema
0000a6 3000                          cpi r16, ESTADO_RELOJ
0000a7 f009                          breq CONTINUAR_VERIFICACION_ALARMA  ; invertimos lgica: si es ESTADO_RELOJ continuar
0000a8 c04b                          rjmp FIN_VERIFICAR_BOTONES_ALARMA   ; si no es ESTADO_RELOJ, salir directamente
                                     
                                 CONTINUAR_VERIFICACION_ALARMA:
0000a9 b103                          in r16, PINB                 ; leer estado actual de los botones
                                     
                                     ; verificar PB1 (entrar en modo programacin de alarma)
0000aa fd01                          sbrc r16, BTN_DEC_SUPERIOR   ; si el bit est a 1 (botn no presionado), saltar
0000ab c018                          rjmp CHECK_BTN_APAGAR_ALARMA ; botn no presionado, verificar siguiente
                                     
                                     ; botn PB1 presionado, verificar si es nueva pulsacin
0000ac 9110 0132                     lds r17, btn_estado_previo+3
0000ae 3011                          cpi r17, 1                   ; estaba liberado antes?
0000af f4a1                          brne CHECK_BTN_APAGAR_ALARMA ; si no, ignorar (evitar repeticin)
                                     
                                     ; nueva pulsacin para entrar en modo alarma
0000b0 e010                          ldi r17, 0                   ; actualizar estado a presionado
0000b1 9310 0132                     sts btn_estado_previo+3, r17
                                     
                                     ; cambiar a modo edicin de alarma
0000b3 e014                          ldi r17, ESTADO_EDICION_ALARMA
0000b4 9310 0134                     sts estado_sistema, r17
                                     
                                     ; inicializar valores de alarma si no estaba activa
0000b6 9110 0128                     lds r17, alarma_activa
0000b8 3011                          cpi r17, 1
0000b9 f051                          breq CHECK_BTN_APAGAR_ALARMA ; si ya estaba activa, mantener valores actuales
                                     
                                     ; inicializar con hora actual
0000ba 9110 011b                     lds r17, contador_horas
0000bc 9310 0127                     sts alarma_horas, r17
0000be 9110 011a                     lds r17, contador_minutos
0000c0 9310 0126                     sts alarma_minutos, r17
0000c2 d03d                          rcall ACTUALIZAR_DISPLAYS_ALARMA
                                     
0000c3 c000                          rjmp CHECK_BTN_APAGAR_ALARMA
                                     
                                 CHECK_BTN_APAGAR_ALARMA:
                                     ; actualizar estado previo del botn PB1
0000c4 ff01                          sbrs r16, BTN_DEC_SUPERIOR   ; si el bit est a 0 (presionado), saltar
0000c5 c003                          rjmp CHECK_BTN_APAGAR_REAL   ; botn sigue presionado
0000c6 e011                          ldi r17, 1                   ; botn liberado
0000c7 9310 0132                     sts btn_estado_previo+3, r17
                                     
                                 CHECK_BTN_APAGAR_REAL:
                                     ; verificar PB0 (apagar alarma si est sonando)
0000c9 fd00                          sbrc r16, BTN_INC_INFERIOR   ; si el bit est a 1 (botn no presionado), saltar
0000ca c00d                          rjmp CHECK_BTN_DESPROGRAMAR  ; botn no presionado, verificar siguiente
                                     
                                     ; botn PB0 presionado, verificar si es nueva pulsacin
0000cb 9110 012f                     lds r17, btn_estado_previo+0
0000cd 3011                          cpi r17, 1                   ; estaba liberado antes?
0000ce f449                          brne CHECK_BTN_DESPROGRAMAR  ; si no, ignorar (evitar repeticin)
                                     
                                     ; nueva pulsacin para apagar alarma
0000cf e010                          ldi r17, 0                   ; actualizar estado a presionado
0000d0 9310 012f                     sts btn_estado_previo+0, r17
                                     
                                     ; verificar si la alarma est sonando
0000d2 9110 0129                     lds r17, alarma_sonando
0000d4 3011                          cpi r17, 1
0000d5 f411                          brne CHECK_BTN_DESPROGRAMAR  ; si no est sonando, ignorar
                                     
                                     ; apagar la alarma
0000d6 d020                          rcall APAGAR_ALARMA
0000d7 c000                          rjmp CHECK_BTN_DESPROGRAMAR
                                     
                                 CHECK_BTN_DESPROGRAMAR:
                                     ; actualizar estado previo del botn PB0
0000d8 ff00                          sbrs r16, BTN_INC_INFERIOR   ; si el bit est a 0 (presionado), saltar
0000d9 c003                          rjmp CHECK_BTN_DESP_REAL     ; botn sigue presionado
0000da e011                          ldi r17, 1                   ; botn liberado
0000db 9310 012f                     sts btn_estado_previo+0, r17
                                     
                                 CHECK_BTN_DESP_REAL:
                                     ; verificar PB3 (desprogramar alarma)
0000dd fd03                          sbrc r16, BTN_DEC_INFERIOR   ; si el bit est a 1 (botn no presionado), saltar
0000de c010                          rjmp FINAL_VERIFICAR_ALARMA  ; botn no presionado, salir
                                     
                                     ; botn PB3 presionado, verificar si es nueva pulsacin
0000df 9110 0130                     lds r17, btn_estado_previo+1
0000e1 3011                          cpi r17, 1                   ; estaba liberado antes?
0000e2 f461                          brne FINAL_VERIFICAR_ALARMA  ; si no, ignorar (evitar repeticin)
                                     
                                     ; nueva pulsacin para desprogramar alarma
0000e3 e010                          ldi r17, 0                   ; actualizar estado a presionado
0000e4 9310 0130                     sts btn_estado_previo+1, r17
                                     
                                     ; desactivar la alarma
0000e6 e010                          ldi r17, 0
0000e7 9310 0128                     sts alarma_activa, r17
                                     
                                     ; apagar LED de alarma en PB5
0000e9 982d                          cbi PORTB, LED_ALARMA
                                     
                                     ; si la alarma estaba sonando, apagarla tambin
0000ea 9110 0129                     lds r17, alarma_sonando
0000ec 3011                          cpi r17, 1
0000ed f409                          brne FINAL_VERIFICAR_ALARMA
0000ee d008                          rcall APAGAR_ALARMA
                                     
                                 FINAL_VERIFICAR_ALARMA:
                                     ; actualizar estado previo del botn PB3
0000ef ff03                          sbrs r16, BTN_DEC_INFERIOR   ; si el bit est a 0 (presionado), saltar
0000f0 c003                          rjmp BTN_ALARMA_EXIT         ; botn sigue presionado
0000f1 e011                          ldi r17, 1                   ; botn liberado
0000f2 9310 0130                     sts btn_estado_previo+1, r17
                                     
                                 BTN_ALARMA_EXIT:
                                     ; No es necesario hacer nada ms
                                     
                                 FIN_VERIFICAR_BOTONES_ALARMA:
0000f4 911f                          pop r17
0000f5 910f                          pop r16
0000f6 9508                          ret
                                 
                                 ; apagar la alarma cuando est sonando
                                 APAGAR_ALARMA:
0000f7 930f                          push r16
                                     
                                     ; apagar el pin de la alarma
0000f8 9840                          cbi PORTC, PIN_ALARMA       ; Apagar seal de alarma en PC0
                                     
                                     ; resetear variables
0000f9 e000                          ldi r16, 0
0000fa 9300 0129                     sts alarma_sonando, r16
0000fc 9300 012a                     sts contador_alarma, r16
                                     
0000fe 910f                          pop r16
0000ff 9508                          ret
                                 
                                 ; actualizar los displays de alarma
                                 ACTUALIZAR_DISPLAYS_ALARMA:
000100 930f                          push r16
000101 931f                          push r17
000102 932f                          push r18
                                     
                                     ; convertir horas a dgitos
000103 9100 0127                     lds r16, alarma_horas
                                     
                                     ; calcular decenas (r16 / 10)
000105 e010                          ldi r17, 0          ; inicializar decenas a 0
000106 300a                          cpi r16, 10         ; comparar con 10
000107 f020                          brlo ALARMA_HORA_DIGITOS ; si es menor que 10, saltar
                                 
                                 ALARMA_DECENAS_LOOP_HORA:
000108 9513                          inc r17             ; incrementar decenas
000109 500a                          subi r16, 10        ; restar 10
00010a 300a                          cpi r16, 10         ; comparar si quedan ms de 10
00010b f7e4                          brge ALARMA_DECENAS_LOOP_HORA ; si quedan ms de 10, repetir
                                     
                                 ALARMA_HORA_DIGITOS:
                                     ; ahora r16 contiene las unidades, r17 contiene las decenas
00010c 9300 0124                     sts alarma_unidades_hora, r16  ; guardar unidades
00010e 9310 0125                     sts alarma_decenas_hora, r17   ; guardar decenas
                                     
                                     ; convertir minutos a dgitos
000110 9100 0126                     lds r16, alarma_minutos
                                     
                                     ; calcular decenas (r16 / 10)
000112 e010                          ldi r17, 0          ; inicializar decenas a 0
000113 300a                          cpi r16, 10         ; comparar con 10
000114 f020                          brlo ALARMA_MIN_DIGITOS ; si es menor que 10, saltar
                                 
                                 ALARMA_DECENAS_LOOP_MIN:
000115 9513                          inc r17             ; incrementar decenas
000116 500a                          subi r16, 10        ; restar 10
000117 300a                          cpi r16, 10         ; comparar si quedan ms de 10
000118 f7e4                          brge ALARMA_DECENAS_LOOP_MIN ; si quedan ms de 10, repetir
                                     
                                 ALARMA_MIN_DIGITOS:
                                     ; ahora r16 contiene las unidades, r17 contiene las decenas
000119 9300 0122                     sts alarma_unidades_min, r16  ; guardar unidades
00011b 9310 0123                     sts alarma_decenas_min, r17   ; guardar decenas
                                     
00011d 912f                          pop r18
00011e 911f                          pop r17
00011f 910f                          pop r16
000120 9508                          ret
                                 
                                 ; verificar botn para cambiar entre modo reloj y fecha (PB4)
                                 VERIFICAR_CAMBIO_MODO_DISPLAY:
000121 930f                          push r16
000122 931f                          push r17
                                     
                                     ; solo permitir cambio de modo si no estamos en modo edicin
000123 9110 0134                     lds r17, estado_sistema
000125 3011                          cpi r17, ESTADO_EDICION_RELOJ
000126 f0c9                          breq SALIR_CAMBIO_MODO      ; si estamos editando reloj, no permitir cambio
                                     
000127 3013                          cpi r17, ESTADO_EDICION_FECHA
000128 f0b9                          breq SALIR_CAMBIO_MODO      ; si estamos editando fecha, no permitir cambio
                                     
000129 3014                          cpi r17, ESTADO_EDICION_ALARMA
00012a f0a9                          breq SALIR_CAMBIO_MODO      ; si estamos editando alarma, no permitir cambio
                                     
00012b b103                          in r16, PINB                ; leer estado actual de los botones
                                     
                                     ; verificar botn de cambio modo display (PB4)
00012c fd04                          sbrc r16, BTN_INC_SUPERIOR  ; si el bit est a 1 (botn no presionado), saltar
00012d c015                          rjmp CHECK_BTN_CAMBIO_MODO  ; botn no presionado, verificar si fue liberado
                                     
                                     ; botn presionado, verificar si es nueva pulsacin
00012e 9110 0131                     lds r17, btn_estado_previo+2
000130 3011                          cpi r17, 1                  ; estaba liberado antes?
000131 f471                          brne SALIR_CAMBIO_MODO      ; si no, ignorar (evitar repeticin)
                                     
                                     ; nueva pulsacin para cambiar entre reloj y fecha
000132 e010                          ldi r17, 0                  ; actualizar estado a presionado
000133 9310 0131                     sts btn_estado_previo+2, r17
                                     
                                     ; cambiar estado del sistema: reloj <-> fecha
000135 9110 0134                     lds r17, estado_sistema
000137 3010                          cpi r17, ESTADO_RELOJ
000138 f421                          brne CAMBIAR_A_RELOJ_DESDE_FECHA
                                     
                                     ; cambiar a modo fecha
000139 e012                          ldi r17, ESTADO_FECHA
00013a 9310 0134                     sts estado_sistema, r17
00013c c003                          rjmp SALIR_CAMBIO_MODO
                                     
                                 CAMBIAR_A_RELOJ_DESDE_FECHA:
                                     ; cambiar a modo reloj
00013d e010                          ldi r17, ESTADO_RELOJ
00013e 9310 0134                     sts estado_sistema, r17
                                     
                                 SALIR_CAMBIO_MODO:
000140 911f                          pop r17
000141 910f                          pop r16
000142 9508                          ret
                                     
                                 CHECK_BTN_CAMBIO_MODO:
                                     ; actualizar estado previo si el botn fue liberado
000143 9110 0131                     lds r17, btn_estado_previo+2
000145 ff04                          sbrs r16, BTN_INC_SUPERIOR  ; si el bit est a 0 (presionado), saltar
000146 cff9                          rjmp SALIR_CAMBIO_MODO      ; botn sigue presionado
000147 e011                          ldi r17, 1                  ; botn liberado
000148 9310 0131                     sts btn_estado_previo+2, r17
00014a cff5                          rjmp SALIR_CAMBIO_MODO
                                 
                                 ; verificar botn para cambiar entre modo normal y edicin (PB2)
                                 VERIFICAR_MODO_EDICION:
00014b 930f                          push r16
00014c 931f                          push r17
                                     
00014d b103                          in r16, PINB                ; leer estado actual de los botones
                                     
                                     ; verificar botn de modo edicin/confirmar (PB2)
00014e fd02                          sbrc r16, BTN_MODO          ; si el bit est a 1 (botn no presionado), saltar
00014f c031                          rjmp CHECK_BTN_MODO_EDICION ; botn no presionado, verificar si fue liberado
                                     
                                     ; botn presionado, verificar si es nueva pulsacin
000150 9110 0133                     lds r17, btn_estado_previo+4
000152 3011                          cpi r17, 1                  ; estaba liberado antes?
000153 f591                          brne SALIR_MODO_EDICION     ; si no, ignorar (evitar repeticin)
                                     
                                     ; nueva pulsacin del botn modo/confirmar
000154 e010                          ldi r17, 0                  ; actualizar estado a presionado
000155 9310 0133                     sts btn_estado_previo+4, r17
                                     
                                     ; cambiar estado segn modo actual
000157 9110 0134                     lds r17, estado_sistema
000159 3010                          cpi r17, ESTADO_RELOJ
00015a f049                          breq CAMBIAR_A_EDICION_RELOJ
                                     
00015b 3011                          cpi r17, ESTADO_EDICION_RELOJ
00015c f059                          breq CAMBIAR_A_RELOJ_NORMAL
                                     
00015d 3012                          cpi r17, ESTADO_FECHA
00015e f091                          breq CAMBIAR_A_EDICION_FECHA
                                     
00015f 3013                          cpi r17, ESTADO_EDICION_FECHA
000160 f0a1                          breq CAMBIAR_A_FECHA_NORMAL
                                     
000161 3014                          cpi r17, ESTADO_EDICION_ALARMA
000162 f0b1                          breq CONFIRMAR_ALARMA
                                     
000163 c022                          rjmp SALIR_MODO_EDICION
                                     
                                 CAMBIAR_A_EDICION_RELOJ:
000164 e011                          ldi r17, ESTADO_EDICION_RELOJ
000165 9310 0134                     sts estado_sistema, r17
000167 c01e                          rjmp SALIR_MODO_EDICION
                                     
                                 CAMBIAR_A_RELOJ_NORMAL:
000168 e010                          ldi r17, ESTADO_RELOJ
000169 9310 0134                     sts estado_sistema, r17
                                     
                                     ; reiniciar contador de segundos para comenzar a contar desde cero
00016b e010                          ldi r17, 0
00016c 9310 012c                     sts contador_segundos, r17
00016e 9310 012b                     sts contador_timer, r17
000170 c015                          rjmp SALIR_MODO_EDICION
                                     
                                 CAMBIAR_A_EDICION_FECHA:
000171 e013                          ldi r17, ESTADO_EDICION_FECHA
000172 9310 0134                     sts estado_sistema, r17
000174 c011                          rjmp SALIR_MODO_EDICION
                                     
                                 CAMBIAR_A_FECHA_NORMAL:
000175 e012                          ldi r17, ESTADO_FECHA
000176 9310 0134                     sts estado_sistema, r17
000178 c00d                          rjmp SALIR_MODO_EDICION
                                     
                                 CONFIRMAR_ALARMA:
                                     ; activar la alarma con los valores configurados
000179 e011                          ldi r17, 1
00017a 9310 0128                     sts alarma_activa, r17
                                     
                                     ; encender LED de alarma activa en PB5
00017c 9a2d                          sbi PORTB, LED_ALARMA
                                     
                                     ; volver a modo reloj
00017d e010                          ldi r17, ESTADO_RELOJ
00017e 9310 0134                     sts estado_sistema, r17
000180 c005                          rjmp SALIR_MODO_EDICION
                                     
                                 CHECK_BTN_MODO_EDICION:
                                     ; actualizar estado previo si el botn fue liberado
000181 ff02                          sbrs r16, BTN_MODO          ; si el bit est a 0 (presionado), saltar
000182 c003                          rjmp SALIR_MODO_EDICION     ; botn sigue presionado
000183 e011                          ldi r17, 1                  ; botn liberado
000184 9310 0133                     sts btn_estado_previo+4, r17
                                     
                                 SALIR_MODO_EDICION:
000186 911f                          pop r17
000187 910f                          pop r16
000188 9508                          ret
                                 
                                 ; verificar el estado de los botones y ajustar segn el modo de edicin
                                 VERIFICAR_BOTONES:
000189 930f                          push r16
00018a 931f                          push r17
00018b 932f                          push r18
                                     
00018c b103                          in r16, PINB                ; leer estado actual de los botones
                                     
                                     ; determinar qu verificar segn el estado actual
00018d 9110 0134                     lds r17, estado_sistema
00018f 3011                          cpi r17, ESTADO_EDICION_RELOJ
000190 f029                          breq VERIFICAR_BOTONES_RELOJ
                                     
000191 3013                          cpi r17, ESTADO_EDICION_FECHA
000192 f029                          breq VERIFICAR_BOTONES_FECHA
                                     
000193 3014                          cpi r17, ESTADO_EDICION_ALARMA
000194 f029                          breq VERIFICAR_BOTONES_ALARMA_EDICION
                                     
000195 c005                          rjmp SALIR_VERIFICAR_BOTONES
                                     
                                 VERIFICAR_BOTONES_RELOJ:
                                     ; verificar botones para editar reloj
000196 d08a                          rcall VERIFICAR_BOTONES_EDICION_RELOJ
000197 c003                          rjmp SALIR_VERIFICAR_BOTONES
                                     
                                 VERIFICAR_BOTONES_FECHA:
                                     ; verificar botones para editar fecha
000198 d0d0                          rcall VERIFICAR_BOTONES_EDICION_FECHA
000199 c001                          rjmp SALIR_VERIFICAR_BOTONES
                                     
                                 VERIFICAR_BOTONES_ALARMA_EDICION:
                                     ; verificar botones para editar alarma
00019a d004                          rcall VERIFICAR_BOTONES_EDICION_ALARMA
                                     
                                 SALIR_VERIFICAR_BOTONES:
00019b 912f                          pop r18
00019c 911f                          pop r17
00019d 910f                          pop r16
00019e 9508                          ret
                                 
                                 ; verificar botones para editar alarma
                                 VERIFICAR_BOTONES_EDICION_ALARMA:
00019f 930f                          push r16
0001a0 931f                          push r17
0001a1 932f                          push r18
                                     
0001a2 b103                          in r16, PINB                ; leer estado actual de los botones
                                     
                                     ; verificar botn de incremento minutos (PB0)
0001a3 fd00                          sbrc r16, BTN_INC_INFERIOR  ; si el bit est a 1 (no presionado), saltar
0001a4 c009                          rjmp CHECK_DEC_MIN_ALARMA   ; botn no presionado, verificar siguiente
                                     
                                     ; botn presionado, verificar si es nueva pulsacin
0001a5 9110 012f                     lds r17, btn_estado_previo+0
0001a7 3011                          cpi r17, 1                  ; estaba liberado antes?
0001a8 f429                          brne CHECK_DEC_MIN_ALARMA   ; si no, ignorar (evitar repeticin)
                                     
                                     ; nueva pulsacin de incremento de minutos de alarma
0001a9 e010                          ldi r17, 0                  ; actualizar estado a presionado
0001aa 9310 012f                     sts btn_estado_previo+0, r17
0001ac d03a                          rcall INCREMENTAR_MINUTOS_ALARMA
0001ad c000                          rjmp CHECK_DEC_MIN_ALARMA
                                     
                                 CHECK_DEC_MIN_ALARMA:
                                     ; actualizar estado previo si el botn fue liberado
0001ae ff00                          sbrs r16, BTN_INC_INFERIOR  ; si el bit est a 0 (presionado), saltar
0001af c003                          rjmp CHECK_BTN_DEC_MIN_ALARMA ; botn sigue presionado
0001b0 e011                          ldi r17, 1                  ; botn liberado
0001b1 9310 012f                     sts btn_estado_previo+0, r17
                                 
                                 CHECK_BTN_DEC_MIN_ALARMA:
                                     ; verificar botn de decremento de minutos (PB3)
0001b3 fd03                          sbrc r16, BTN_DEC_INFERIOR  ; si el bit est a 1 (no presionado), saltar
0001b4 c009                          rjmp CHECK_INC_HORA_ALARMA  ; botn no presionado, verificar siguiente
                                     
                                     ; botn presionado, verificar si es nueva pulsacin
0001b5 9110 0130                     lds r17, btn_estado_previo+1
0001b7 3011                          cpi r17, 1                  ; estaba liberado antes?
0001b8 f429                          brne CHECK_INC_HORA_ALARMA  ; si no, ignorar (evitar repeticin)
                                     
                                     ; nueva pulsacin de decremento de minutos de alarma
0001b9 e010                          ldi r17, 0                  ; actualizar estado a presionado
0001ba 9310 0130                     sts btn_estado_previo+1, r17
0001bc d038                          rcall DECREMENTAR_MINUTOS_ALARMA
0001bd c000                          rjmp CHECK_INC_HORA_ALARMA
                                     
                                 CHECK_INC_HORA_ALARMA:
                                     ; actualizar estado previo si el botn fue liberado
0001be ff03                          sbrs r16, BTN_DEC_INFERIOR  ; si el bit est a 0 (presionado), saltar
0001bf c003                          rjmp CHECK_BTN_INC_HORA_ALARMA ; botn sigue presionado
0001c0 e011                          ldi r17, 1                  ; botn liberado
0001c1 9310 0130                     sts btn_estado_previo+1, r17
                                 
                                 CHECK_BTN_INC_HORA_ALARMA:
                                     ; verificar botn de incremento de horas (PB4)
0001c3 fd04                          sbrc r16, BTN_INC_SUPERIOR  ; si el bit est a 1 (no presionado), saltar
0001c4 c009                          rjmp CHECK_DEC_HORA_ALARMA  ; botn no presionado, verificar siguiente
                                     
                                     ; botn presionado, verificar si es nueva pulsacin
0001c5 9110 0131                     lds r17, btn_estado_previo+2
0001c7 3011                          cpi r17, 1                  ; estaba liberado antes?
0001c8 f429                          brne CHECK_DEC_HORA_ALARMA  ; si no, ignorar (evitar repeticin)
                                     
                                     ; nueva pulsacin de incremento de horas de alarma
0001c9 e010                          ldi r17, 0                  ; actualizar estado a presionado
0001ca 9310 0131                     sts btn_estado_previo+2, r17
0001cc d037                          rcall INCREMENTAR_HORAS_ALARMA
0001cd c000                          rjmp CHECK_DEC_HORA_ALARMA
                                     
                                 CHECK_DEC_HORA_ALARMA:
                                     ; actualizar estado previo si el botn fue liberado
0001ce ff04                          sbrs r16, BTN_INC_SUPERIOR  ; si el bit est a 0 (presionado), saltar
0001cf c003                          rjmp CHECK_BTN_DEC_HORA_ALARMA ; botn sigue presionado
0001d0 e011                          ldi r17, 1                  ; botn liberado
0001d1 9310 0131                     sts btn_estado_previo+2, r17
                                 
                                 CHECK_BTN_DEC_HORA_ALARMA:
                                     ; verificar botn de decremento de horas (PB1)
0001d3 fd01                          sbrc r16, BTN_DEC_SUPERIOR  ; si el bit est a 1 (no presionado), saltar
0001d4 c009                          rjmp END_BTN_CHECK_ALARMA   ; botn no presionado, finalizar
                                     
                                     ; botn presionado, verificar si es nueva pulsacin
0001d5 9110 0132                     lds r17, btn_estado_previo+3
0001d7 3011                          cpi r17, 1                  ; estaba liberado antes?
0001d8 f429                          brne END_BTN_CHECK_ALARMA   ; si no, ignorar (evitar repeticin)
                                     
                                     ; nueva pulsacin de decremento de horas de alarma
0001d9 e010                          ldi r17, 0                  ; actualizar estado a presionado
0001da 9310 0132                     sts btn_estado_previo+3, r17
0001dc d035                          rcall DECREMENTAR_HORAS_ALARMA
0001dd c000                          rjmp END_BTN_CHECK_ALARMA
                                     
                                 END_BTN_CHECK_ALARMA:
                                     ; actualizar estado previo si el botn fue liberado
0001de ff01                          sbrs r16, BTN_DEC_SUPERIOR  ; si el bit est a 0 (presionado), saltar
0001df c003                          rjmp BTN_CHECK_EXIT_ALARMA  ; botn sigue presionado
0001e0 e011                          ldi r17, 1                  ; botn liberado
0001e1 9310 0132                     sts btn_estado_previo+3, r17
                                 
                                 BTN_CHECK_EXIT_ALARMA:
0001e3 912f                          pop r18
0001e4 911f                          pop r17
0001e5 910f                          pop r16
0001e6 9508                          ret
                                 
                                 ; incrementar minutos de alarma (0-59)
                                 INCREMENTAR_MINUTOS_ALARMA:
0001e7 930f                          push r16
0001e8 931f                          push r17
                                     
                                     ; obtener valor actual
0001e9 9100 0126                     lds r16, alarma_minutos
                                     
                                     ; incrementar contador
0001eb 9503                          inc r16
                                     
                                     ; verificar lmite (0-59)
0001ec 330c                          cpi r16, 60
0001ed f008                          brlo GUAR_MINUTOS_ALARMA_CONTADOR
                                     
                                     ; reset a 0 si lleg a 60
0001ee e000                          ldi r16, 0
                                     
                                 GUAR_MINUTOS_ALARMA_CONTADOR:
                                     ; guardar nuevo valor
0001ef 9300 0126                     sts alarma_minutos, r16
                                     
                                     ; actualizar display
0001f1 df0e                          rcall ACTUALIZAR_DISPLAYS_ALARMA
                                     
0001f2 911f                          pop r17
0001f3 910f                          pop r16
0001f4 9508                          ret
                                 
                                 ; decrementar minutos de alarma (0-59)
                                 DECREMENTAR_MINUTOS_ALARMA:
0001f5 930f                          push r16
0001f6 931f                          push r17
                                     
                                     ; obtener valor actual
0001f7 9100 0126                     lds r16, alarma_minutos
                                     
                                     ; si ya est en 0, ir a 59
0001f9 3000                          cpi r16, 0
0001fa f411                          brne DEC_MIN_ALARMA_NORMAL
                                     
0001fb e30b                          ldi r16, 59
0001fc c001                          rjmp GUAR_MINUTOS_ALARMA_CONTADOR_DEC
                                     
                                 DEC_MIN_ALARMA_NORMAL:
                                     ; decrementar normalmente
0001fd 950a                          dec r16
                                     
                                 GUAR_MINUTOS_ALARMA_CONTADOR_DEC:
                                     ; guardar nuevo valor
0001fe 9300 0126                     sts alarma_minutos, r16
                                     
                                     ; actualizar display
000200 deff                          rcall ACTUALIZAR_DISPLAYS_ALARMA
                                     
000201 911f                          pop r17
000202 910f                          pop r16
000203 9508                          ret
                                 
                                 ; incrementar horas de alarma (0-23)
                                 INCREMENTAR_HORAS_ALARMA:
000204 930f                          push r16
000205 931f                          push r17
                                     
                                     ; obtener valor actual
000206 9100 0127                     lds r16, alarma_horas
                                     
                                     ; incrementar contador
000208 9503                          inc r16
                                     
                                     ; verificar lmite (0-23)
000209 3108                          cpi r16, 24
00020a f008                          brlo GUAR_HORAS_ALARMA_CONTADOR
                                     
                                     ; reset a 0 si lleg a 24
00020b e000                          ldi r16, 0
                                     
                                 GUAR_HORAS_ALARMA_CONTADOR:
                                     ; guardar nuevo valor
00020c 9300 0127                     sts alarma_horas, r16
                                     
                                     ; actualizar display
00020e def1                          rcall ACTUALIZAR_DISPLAYS_ALARMA
                                     
00020f 911f                          pop r17
000210 910f                          pop r16
000211 9508                          ret
                                 
                                 ; decrementar horas de alarma (0-23)
                                 DECREMENTAR_HORAS_ALARMA:
000212 930f                          push r16
000213 931f                          push r17
                                     
                                     ; obtener valor actual
000214 9100 0127                     lds r16, alarma_horas
                                     
                                     ; si ya est en 0, ir a 23
000216 3000                          cpi r16, 0
000217 f411                          brne DEC_HORA_ALARMA_NORMAL
                                     
000218 e107                          ldi r16, 23
000219 c001                          rjmp GUAR_HORAS_ALARMA_CONTADOR_DEC
                                     
                                 DEC_HORA_ALARMA_NORMAL:
                                     ; decrementar normalmente
00021a 950a                          dec r16
                                     
                                 GUAR_HORAS_ALARMA_CONTADOR_DEC:
                                     ; guardar nuevo valor
00021b 9300 0127                     sts alarma_horas, r16
                                     
                                     ; actualizar display
00021d dee2                          rcall ACTUALIZAR_DISPLAYS_ALARMA
                                     
00021e 911f                          pop r17
00021f 910f                          pop r16
000220 9508                          ret
                                 
                                 ; verificar botones para editar reloj
                                 VERIFICAR_BOTONES_EDICION_RELOJ:
000221 930f                          push r16
000222 931f                          push r17
000223 932f                          push r18
                                     
000224 b103                          in r16, PINB                ; leer estado actual de los botones
                                     
                                     ; verificar botn de incremento minutos (PB0)
000225 fd00                          sbrc r16, BTN_INC_INFERIOR  ; si el bit est a 1 (no presionado), saltar
000226 c009                          rjmp CHECK_DEC_MIN          ; botn no presionado, verificar siguiente
                                     
                                     ; botn presionado, verificar si es nueva pulsacin
000227 9110 012f                     lds r17, btn_estado_previo+0
000229 3011                          cpi r17, 1                  ; estaba liberado antes?
00022a f429                          brne CHECK_DEC_MIN          ; si no, ignorar (evitar repeticin)
                                     
                                     ; nueva pulsacin de incremento de minutos
00022b e010                          ldi r17, 0                  ; actualizar estado a presionado
00022c 9310 012f                     sts btn_estado_previo+0, r17
00022e d082                          rcall INCREMENTAR_MINUTOS
00022f c000                          rjmp CHECK_DEC_MIN
                                     
                                 CHECK_DEC_MIN:
                                     ; actualizar estado previo si el botn fue liberado
000230 ff00                          sbrs r16, BTN_INC_INFERIOR  ; si el bit est a 0 (presionado), saltar
000231 c003                          rjmp CHECK_BTN_DEC_MIN      ; botn sigue presionado
000232 e011                          ldi r17, 1                  ; botn liberado
000233 9310 012f                     sts btn_estado_previo+0, r17
                                 
                                 CHECK_BTN_DEC_MIN:
                                     ; verificar botn de decremento de minutos (PB3)
000235 fd03                          sbrc r16, BTN_DEC_INFERIOR  ; si el bit est a 1 (no presionado), saltar
000236 c009                          rjmp CHECK_INC_HORA         ; botn no presionado, verificar siguiente
                                     
                                     ; botn presionado, verificar si es nueva pulsacin
000237 9110 0130                     lds r17, btn_estado_previo+1
000239 3011                          cpi r17, 1                  ; estaba liberado antes?
00023a f429                          brne CHECK_INC_HORA         ; si no, ignorar (evitar repeticin)
                                     
                                     ; nueva pulsacin de decremento de minutos
00023b e010                          ldi r17, 0                  ; actualizar estado a presionado
00023c 9310 0130                     sts btn_estado_previo+1, r17
00023e d080                          rcall DECREMENTAR_MINUTOS
00023f c000                          rjmp CHECK_INC_HORA
                                     
                                 CHECK_INC_HORA:
                                     ; actualizar estado previo si el botn fue liberado
000240 ff03                          sbrs r16, BTN_DEC_INFERIOR  ; si el bit est a 0 (presionado), saltar
000241 c003                          rjmp CHECK_BTN_INC_HORA     ; botn sigue presionado
000242 e011                          ldi r17, 1                  ; botn liberado
000243 9310 0130                     sts btn_estado_previo+1, r17
                                 
                                 CHECK_BTN_INC_HORA:
                                     ; verificar botn de incremento de horas (PB4)
000245 fd04                          sbrc r16, BTN_INC_SUPERIOR  ; si el bit est a 1 (no presionado), saltar
000246 c009                          rjmp CHECK_DEC_HORA         ; botn no presionado, verificar siguiente
                                     
                                     ; botn presionado, verificar si es nueva pulsacin
000247 9110 0131                     lds r17, btn_estado_previo+2
000249 3011                          cpi r17, 1                  ; estaba liberado antes?
00024a f429                          brne CHECK_DEC_HORA         ; si no, ignorar (evitar repeticin)
                                     
                                     ; nueva pulsacin de incremento de horas
00024b e010                          ldi r17, 0                  ; actualizar estado a presionado
00024c 9310 0131                     sts btn_estado_previo+2, r17
00024e d07f                          rcall INCREMENTAR_HORAS
00024f c000                          rjmp CHECK_DEC_HORA
                                     
                                 CHECK_DEC_HORA:
                                     ; actualizar estado previo si el botn fue liberado
000250 ff04                          sbrs r16, BTN_INC_SUPERIOR  ; si el bit est a 0 (presionado), saltar
000251 c003                          rjmp CHECK_BTN_DEC_HORA     ; botn sigue presionado
000252 e011                          ldi r17, 1                  ; botn liberado
000253 9310 0131                     sts btn_estado_previo+2, r17
                                 
                                 CHECK_BTN_DEC_HORA:
                                     ; verificar botn de decremento de horas (PB1)
000255 fd01                          sbrc r16, BTN_DEC_SUPERIOR  ; si el bit est a 1 (no presionado), saltar
000256 c009                          rjmp END_BTN_CHECK_RELOJ    ; botn no presionado, finalizar
                                     
                                     ; botn presionado, verificar si es nueva pulsacin
000257 9110 0132                     lds r17, btn_estado_previo+3
000259 3011                          cpi r17, 1                  ; estaba liberado antes?
00025a f429                          brne END_BTN_CHECK_RELOJ    ; si no, ignorar (evitar repeticin)
                                     
                                     ; nueva pulsacin de decremento de horas
00025b e010                          ldi r17, 0                  ; actualizar estado a presionado
00025c 9310 0132                     sts btn_estado_previo+3, r17
00025e d07d                          rcall DECREMENTAR_HORAS
00025f c000                          rjmp END_BTN_CHECK_RELOJ
                                     
                                 END_BTN_CHECK_RELOJ:
                                     ; actualizar estado previo si el botn fue liberado
000260 ff01                          sbrs r16, BTN_DEC_SUPERIOR  ; si el bit est a 0 (presionado), saltar
000261 c003                          rjmp BTN_CHECK_EXIT_RELOJ   ; botn sigue presionado
000262 e011                          ldi r17, 1                  ; botn liberado
000263 9310 0132                     sts btn_estado_previo+3, r17
                                 
                                 BTN_CHECK_EXIT_RELOJ:
000265 912f                          pop r18
000266 911f                          pop r17
000267 910f                          pop r16
000268 9508                          ret
                                 
                                 ; verificar botones para editar fecha
                                 VERIFICAR_BOTONES_EDICION_FECHA:
000269 930f                          push r16
00026a 931f                          push r17
00026b 932f                          push r18
                                     
00026c b103                          in r16, PINB                ; leer estado actual de los botones
                                     
                                     ; verificar botn de incremento da (PB0)
00026d fd00                          sbrc r16, BTN_INC_INFERIOR  ; si el bit est a 1 (no presionado), saltar
00026e c009                          rjmp CHECK_DEC_DIA          ; botn no presionado, verificar siguiente
                                     
                                     ; botn presionado, verificar si es nueva pulsacin
00026f 9110 012f                     lds r17, btn_estado_previo+0
000271 3011                          cpi r17, 1                  ; estaba liberado antes?
000272 f429                          brne CHECK_DEC_DIA          ; si no, ignorar (evitar repeticin)
                                     
                                     ; nueva pulsacin de incremento de da
000273 e010                          ldi r17, 0                  ; actualizar estado a presionado
000274 9310 012f                     sts btn_estado_previo+0, r17
000276 d099                          rcall INCREMENTAR_DIA
000277 c000                          rjmp CHECK_DEC_DIA
                                     
                                 CHECK_DEC_DIA:
                                     ; actualizar estado previo si el botn fue liberado
000278 ff00                          sbrs r16, BTN_INC_INFERIOR  ; si el bit est a 0 (presionado), saltar
000279 c003                          rjmp CHECK_BTN_DEC_DIA      ; botn sigue presionado
00027a e011                          ldi r17, 1                  ; botn liberado
00027b 9310 012f                     sts btn_estado_previo+0, r17
                                 
                                 CHECK_BTN_DEC_DIA:
                                     ; verificar botn de decremento de da (PB3)
00027d fd03                          sbrc r16, BTN_DEC_INFERIOR  ; si el bit est a 1 (no presionado), saltar
00027e c009                          rjmp CHECK_INC_MES          ; botn no presionado, verificar siguiente
                                     
                                     ; botn presionado, verificar si es nueva pulsacin
00027f 9110 0130                     lds r17, btn_estado_previo+1
000281 3011                          cpi r17, 1                  ; estaba liberado antes?
000282 f429                          brne CHECK_INC_MES          ; si no, ignorar (evitar repeticin)
                                     
                                     ; nueva pulsacin de decremento de da
000283 e010                          ldi r17, 0                  ; actualizar estado a presionado
000284 9310 0130                     sts btn_estado_previo+1, r17
000286 d0a2                          rcall DECREMENTAR_DIA
000287 c000                          rjmp CHECK_INC_MES
                                     
                                 CHECK_INC_MES:
                                     ; actualizar estado previo si el botn fue liberado
000288 ff03                          sbrs r16, BTN_DEC_INFERIOR  ; si el bit est a 0 (presionado), saltar
000289 c003                          rjmp CHECK_BTN_INC_MES      ; botn sigue presionado
00028a e011                          ldi r17, 1                  ; botn liberado
00028b 9310 0130                     sts btn_estado_previo+1, r17
                                 
                                 CHECK_BTN_INC_MES:
                                     ; verificar botn de incremento de mes (PB4)
00028d fd04                          sbrc r16, BTN_INC_SUPERIOR  ; si el bit est a 1 (no presionado), saltar
00028e c009                          rjmp CHECK_DEC_MES          ; botn no presionado, verificar siguiente
                                     
                                     ; botn presionado, verificar si es nueva pulsacin
00028f 9110 0131                     lds r17, btn_estado_previo+2
000291 3011                          cpi r17, 1                  ; estaba liberado antes?
000292 f429                          brne CHECK_DEC_MES          ; si no, ignorar (evitar repeticin)
                                     
                                     ; nueva pulsacin de incremento de mes
000293 e010                          ldi r17, 0                  ; actualizar estado a presionado
000294 9310 0131                     sts btn_estado_previo+2, r17
000296 d0a6                          rcall INCREMENTAR_MES
000297 c000                          rjmp CHECK_DEC_MES
                                     
                                 CHECK_DEC_MES:
                                     ; actualizar estado previo si el botn fue liberado
000298 ff04                          sbrs r16, BTN_INC_SUPERIOR  ; si el bit est a 0 (presionado), saltar
000299 c003                          rjmp CHECK_BTN_DEC_MES      ; botn sigue presionado
00029a e011                          ldi r17, 1                  ; botn liberado
00029b 9310 0131                     sts btn_estado_previo+2, r17
                                 
                                 CHECK_BTN_DEC_MES:
                                     ; verificar botn de decremento de mes (PB1)
00029d fd01                          sbrc r16, BTN_DEC_SUPERIOR  ; si el bit est a 1 (no presionado), saltar
00029e c009                          rjmp END_BTN_CHECK_FECHA    ; botn no presionado, finalizar
                                     
                                     ; botn presionado, verificar si es nueva pulsacin
00029f 9110 0132                     lds r17, btn_estado_previo+3
0002a1 3011                          cpi r17, 1                  ; estaba liberado antes?
0002a2 f429                          brne END_BTN_CHECK_FECHA    ; si no, ignorar (evitar repeticin)
                                     
                                     ; nueva pulsacin de decremento de mes
0002a3 e010                          ldi r17, 0                  ; actualizar estado a presionado
0002a4 9310 0132                     sts btn_estado_previo+3, r17
0002a6 d0a5                          rcall DECREMENTAR_MES
0002a7 c000                          rjmp END_BTN_CHECK_FECHA
                                     
                                 END_BTN_CHECK_FECHA:
                                     ; actualizar estado previo si el botn fue liberado
0002a8 ff01                          sbrs r16, BTN_DEC_SUPERIOR  ; si el bit est a 0 (presionado), saltar
0002a9 c003                          rjmp BTN_CHECK_EXIT_FECHA   ; botn sigue presionado
0002aa e011                          ldi r17, 1                  ; botn liberado
0002ab 9310 0132                     sts btn_estado_previo+3, r17
                                 
                                 BTN_CHECK_EXIT_FECHA:
0002ad 912f                          pop r18
0002ae 911f                          pop r17
0002af 910f                          pop r16
0002b0 9508                          ret
                                 
                                 ; incrementar minutos (0-59)
                                 INCREMENTAR_MINUTOS:
0002b1 930f                          push r16
0002b2 931f                          push r17
                                     
                                     ; obtener valor actual
0002b3 9100 011a                     lds r16, contador_minutos
                                     
                                     ; incrementar contador
0002b5 9503                          inc r16
                                     
                                     ; verificar lmite (0-59)
0002b6 330c                          cpi r16, 60
0002b7 f008                          brlo GUAR_MINUTOS_CONTADOR
                                     
                                     ; reset a 0 si lleg a 60
0002b8 e000                          ldi r16, 0
                                     
                                 GUAR_MINUTOS_CONTADOR:
                                     ; guardar nuevo valor
0002b9 9300 011a                     sts contador_minutos, r16
                                     
                                     ; convertir a decenas y unidades para mostrar en display
0002bb d0b4                          rcall ACTUALIZAR_DISPLAYS_MINUTOS
                                     
0002bc 911f                          pop r17
0002bd 910f                          pop r16
0002be 9508                          ret
                                 
                                 ; decrementar minutos (0-59)
                                 DECREMENTAR_MINUTOS:
0002bf 930f                          push r16
0002c0 931f                          push r17
                                     
                                     ; obtener valor actual
0002c1 9100 011a                     lds r16, contador_minutos
                                     
                                     ; si ya est en 0, ir a 59
0002c3 3000                          cpi r16, 0
0002c4 f411                          brne DEC_MIN_NORMAL
                                     
0002c5 e30b                          ldi r16, 59
0002c6 c001                          rjmp GUAR_MINUTOS_CONTADOR_DEC
                                     
                                 DEC_MIN_NORMAL:
                                     ; decrementar normalmente
0002c7 950a                          dec r16
                                     
                                 GUAR_MINUTOS_CONTADOR_DEC:
                                     ; guardar nuevo valor
0002c8 9300 011a                     sts contador_minutos, r16
                                     
                                     ; convertir a decenas y unidades para mostrar en display
0002ca d0a5                          rcall ACTUALIZAR_DISPLAYS_MINUTOS
                                     
0002cb 911f                          pop r17
0002cc 910f                          pop r16
0002cd 9508                          ret
                                 
                                 ; incrementar horas (0-23)
                                 INCREMENTAR_HORAS:
0002ce 930f                          push r16
0002cf 931f                          push r17
                                     
                                     ; obtener valor actual
0002d0 9100 011b                     lds r16, contador_horas
                                     
                                     ; incrementar contador
0002d2 9503                          inc r16
                                     
                                     ; verificar lmite (0-23)
0002d3 3108                          cpi r16, 24
0002d4 f008                          brlo GUAR_HORAS_CONTADOR
                                     
                                     ; reset a 0 si lleg a 24
0002d5 e000                          ldi r16, 0
                                     
                                 GUAR_HORAS_CONTADOR:
                                     ; guardar nuevo valor
0002d6 9300 011b                     sts contador_horas, r16
                                     
                                     ; convertir a decenas y unidades para mostrar en display
0002d8 d0ab                          rcall ACTUALIZAR_DISPLAYS_HORAS
                                     
0002d9 911f                          pop r17
0002da 910f                          pop r16
0002db 9508                          ret
                                 
                                 ; decrementar horas (0-23)
                                 DECREMENTAR_HORAS:
0002dc 930f                          push r16
0002dd 931f                          push r17
                                     
                                     ; obtener valor actual
0002de 9100 011b                     lds r16, contador_horas
                                     
                                     ; si ya est en 0, ir a 23
0002e0 3000                          cpi r16, 0
0002e1 f411                          brne DEC_HORA_NORMAL
                                     
0002e2 e107                          ldi r16, 23
0002e3 c001                          rjmp GUAR_HORAS_CONTADOR_DEC
                                     
                                 DEC_HORA_NORMAL:
                                     ; decrementar normalmente
0002e4 950a                          dec r16
                                     
                                 GUAR_HORAS_CONTADOR_DEC:
                                     ; guardar nuevo valor
0002e5 9300 011b                     sts contador_horas, r16
                                     
                                     ; convertir a decenas y unidades para mostrar en display
0002e7 d09c                          rcall ACTUALIZAR_DISPLAYS_HORAS
                                     
0002e8 911f                          pop r17
0002e9 910f                          pop r16
0002ea 9508                          ret
                                 
                                 ; inicializar tabla de das por mes (1-12)
                                 INICIAR_TABLA_DIAS:
0002eb e0f1                          ldi ZH, HIGH(dias_por_mes)
0002ec e0ea                          ldi ZL, LOW(dias_por_mes)
                                     
0002ed e10f                          ldi r16, 31        ; Enero: 31 das
0002ee 9301                          st Z+, r16
0002ef e10c                          ldi r16, 28        ; Febrero: 28 das 
0002f0 9301                          st Z+, r16
0002f1 e10f                          ldi r16, 31        ; Marzo: 31 das
0002f2 9301                          st Z+, r16
0002f3 e10e                          ldi r16, 30        ; Abril: 30 das
0002f4 9301                          st Z+, r16
0002f5 e10f                          ldi r16, 31        ; Mayo: 31 das
0002f6 9301                          st Z+, r16
0002f7 e10e                          ldi r16, 30        ; Junio: 30 das
0002f8 9301                          st Z+, r16
0002f9 e10f                          ldi r16, 31        ; Julio: 31 das
0002fa 9301                          st Z+, r16
0002fb e10f                          ldi r16, 31        ; Agosto: 31 das
0002fc 9301                          st Z+, r16
0002fd e10e                          ldi r16, 30        ; Septiembre: 30 das
0002fe 9301                          st Z+, r16
0002ff e10f                          ldi r16, 31        ; Octubre: 31 das
000300 9301                          st Z+, r16
000301 e10e                          ldi r16, 30        ; Noviembre: 30 das
000302 9301                          st Z+, r16
000303 e10f                          ldi r16, 31        ; Diciembre: 31 das
000304 9301                          st Z+, r16
                                     
000305 9508                          ret
                                 
                                 ; obtener nmero mximo de das para el mes actual
                                 OBTENER_DIAS_MES:
000306 931f                          push r17
                                     
                                     ; r16 debe contener el mes (1-12)
000307 950a                          dec r16                ; ajustar a ndice 0-11 para acceder a la tabla
                                     
                                     ; cargar direccin de la tabla
000308 e0f1                          ldi ZH, HIGH(dias_por_mes)
000309 e0ea                          ldi ZL, LOW(dias_por_mes)
                                     
                                     ; calcular posicin en la tabla
00030a 0fe0                          add ZL, r16            ; sumar offset
00030b f408                          brcc PC+2              ; si no hay carry, saltar
00030c 95f3                          inc ZH                 ; si hay carry, incrementar ZH
                                     
                                     ; cargar valor desde la tabla
00030d 8100                          ld r16, Z              ; r16 ahora contiene el nmero mximo de das
                                     
00030e 911f                          pop r17
00030f 9508                          ret
                                 
                                 ; incrementar da (1-31, dependiendo del mes)
                                 INCREMENTAR_DIA:
000310 930f                          push r16
000311 931f                          push r17
000312 932f                          push r18
                                     
                                     ; obtener valor actual del da
000313 9100 0120                     lds r16, contador_dia
                                     
                                     ; incrementar contador
000315 9503                          inc r16
                                     
                                     ; obtener lmite mximo de das para el mes actual
000316 9110 0121                     lds r17, contador_mes  ; cargar mes actual en r17
000318 2f20                          mov r18, r16           ; guardar da incrementado en r18
000319 2f01                          mov r16, r17           ; mover mes a r16 para funcin
00031a dfeb                          rcall OBTENER_DIAS_MES ; r16 ahora contiene das mximos
00031b 2f10                          mov r17, r16           ; das mximos en r17
00031c 2f02                          mov r16, r18           ; restaurar da incrementado en r16
                                     
                                     ; verificar si excedi el lmite
00031d 1701                          cp r16, r17
00031e f018                          brlo GUAR_DIA_CONTADOR ; si da < das mximos, guardar
00031f 1710                          cp r17, r16
000320 f009                          breq GUAR_DIA_CONTADOR ; si da == das mximos, guardar
                                     
                                     ; reset a 1 si excedi el lmite
000321 e001                          ldi r16, 1
                                     
                                 GUAR_DIA_CONTADOR:
                                     ; guardar nuevo valor
000322 9300 0120                     sts contador_dia, r16
                                     
                                     ; actualizar dgitos para mostrar en display
000324 d073                          rcall ACTUALIZAR_DISPLAYS_DIA
                                     
000325 912f                          pop r18
000326 911f                          pop r17
000327 910f                          pop r16
000328 9508                          ret
                                 
                                 ; decrementar da (1-31, dependiendo del mes)
                                 DECREMENTAR_DIA:
000329 930f                          push r16
00032a 931f                          push r17
00032b 932f                          push r18
                                     
                                     ; obtener valor actual
00032c 9100 0120                     lds r16, contador_dia
                                     
                                     ; si ya est en 1, ir al ltimo da del mes
00032e 3001                          cpi r16, 1
00032f f429                          brne DEC_DIA_NORMAL
                                     
                                     ; obtener nmero mximo de das para el mes actual
000330 9110 0121                     lds r17, contador_mes  ; cargar mes actual
000332 2f01                          mov r16, r17           ; mover mes a r16 para funcin
000333 dfd2                          rcall OBTENER_DIAS_MES ; r16 ahora contiene das mximos
000334 c001                          rjmp GUAR_DIA_CONTADOR_DEC
                                     
                                 DEC_DIA_NORMAL:
                                     ; decrementar normalmente
000335 950a                          dec r16
                                     
                                 GUAR_DIA_CONTADOR_DEC:
                                     ; guardar nuevo valor
000336 9300 0120                     sts contador_dia, r16
                                     
                                     ; actualizar dgitos para mostrar en display
000338 d05f                          rcall ACTUALIZAR_DISPLAYS_DIA
                                     
000339 912f                          pop r18
00033a 911f                          pop r17
00033b 910f                          pop r16
00033c 9508                          ret
                                 
                                 ; incrementar mes (1-12)
                                 INCREMENTAR_MES:
00033d 930f                          push r16
00033e 931f                          push r17
                                     
                                     ; obtener valor actual
00033f 9100 0121                     lds r16, contador_mes
                                     
                                     ; incrementar contador
000341 9503                          inc r16
                                     
                                     ; verificar lmite (1-12)
000342 300d                          cpi r16, 13
000343 f008                          brlo GUAR_MES_CONTADOR
                                     
                                     ; reset a 1 si lleg a 13
000344 e001                          ldi r16, 1
                                     
                                 GUAR_MES_CONTADOR:
                                     ; guardar nuevo valor
000345 9300 0121                     sts contador_mes, r16
                                     
                                     ; convertir a decenas y unidades para mostrar en display
000347 d064                          rcall ACTUALIZAR_DISPLAYS_MES
                                     
                                     ; verificar si el da actual es vlido para el nuevo mes
000348 d013                          rcall AJUSTAR_DIA_A_MES
                                     
000349 911f                          pop r17
00034a 910f                          pop r16
00034b 9508                          ret
                                 
                                 ; decrementar mes (1-12)
                                 DECREMENTAR_MES:
00034c 930f                          push r16
00034d 931f                          push r17
                                     
                                     ; obtener valor actual
00034e 9100 0121                     lds r16, contador_mes
                                     
                                     ; si ya est en 1, ir a 12
000350 3001                          cpi r16, 1
000351 f411                          brne DEC_MES_NORMAL
                                     
000352 e00c                          ldi r16, 12
000353 c001                          rjmp GUAR_MES_CONTADOR_DEC
                                     
                                 DEC_MES_NORMAL:
                                     ; decrementar normalmente
000354 950a                          dec r16
                                     
                                 GUAR_MES_CONTADOR_DEC:
                                     ; guardar nuevo valor
000355 9300 0121                     sts contador_mes, r16
                                     
                                     ; convertir a decenas y unidades para mostrar en display
000357 d054                          rcall ACTUALIZAR_DISPLAYS_MES
                                     
                                     ; verificar si el da actual es vlido para el nuevo mes
000358 d003                          rcall AJUSTAR_DIA_A_MES
                                     
000359 911f                          pop r17
00035a 910f                          pop r16
00035b 9508                          ret
                                 
                                 ; ajustar el da si excede el mximo del mes actual
                                 AJUSTAR_DIA_A_MES:
00035c 930f                          push r16
00035d 931f                          push r17
                                     
                                     ; obtener das mximos para el mes actual
00035e 9100 0121                     lds r16, contador_mes
000360 dfa5                          rcall OBTENER_DIAS_MES  ; r16 ahora contiene das mximos
000361 2f10                          mov r17, r16            ; das mximos en r17
                                     
                                     ; comparar con da actual
000362 9100 0120                     lds r16, contador_dia
000364 1701                          cp r16, r17
000365 f038                          brlo AJUSTE_DIA_FIN     ; si da < das mximos, no ajustar
000366 1710                          cp r17, r16
000367 f409                          brne AJUSTE_DIA_MES     ; si da != das mximos, ajustar
000368 c004                          rjmp AJUSTE_DIA_FIN     ; si da == das mximos, no ajustar
                                     
                                 AJUSTE_DIA_MES:
                                     ; da excede mximo, ajustar al mximo
000369 2f01                          mov r16, r17            ; r16 = das mximos
00036a 9300 0120                     sts contador_dia, r16
                                     
                                     ; actualizar displays
00036c d02b                          rcall ACTUALIZAR_DISPLAYS_DIA
                                     
                                 AJUSTE_DIA_FIN:
00036d 911f                          pop r17
00036e 910f                          pop r16
00036f 9508                          ret
                                 
                                 ; actualizar los displays de minutos basado en contador_minutos
                                 ACTUALIZAR_DISPLAYS_MINUTOS:
000370 930f                          push r16
000371 931f                          push r17
000372 932f                          push r18
                                     
                                     ; cargar valor del contador
000373 9100 011a                     lds r16, contador_minutos
                                     
                                     ; calcular decenas (r16 / 10)
000375 e010                          ldi r17, 0          ; inicializar decenas a 0
000376 300a                          cpi r16, 10         ; comparar con 10
000377 f020                          brlo GUAR_MIN_DIGITOS ; si es menor que 10, saltar
                                 
                                 DECENAS_LOOP_MIN:
000378 9513                          inc r17             ; incrementar decenas
000379 500a                          subi r16, 10        ; restar 10
00037a 300a                          cpi r16, 10         ; comparar si quedan ms de 10
00037b f7e4                          brge DECENAS_LOOP_MIN ; si quedan ms de 10, repetir
                                     
                                 GUAR_MIN_DIGITOS:
                                     ; ahora r16 contiene las unidades, r17 contiene las decenas
00037c 9300 0116                     sts contador_unidades_min, r16  ; guardar unidades
00037e 9310 0117                     sts contador_decenas_min, r17   ; guardar decenas
                                     
000380 912f                          pop r18
000381 911f                          pop r17
000382 910f                          pop r16
000383 9508                          ret
                                 
                                 ; actualizar los displays de horas basado en contador_horas
                                 ACTUALIZAR_DISPLAYS_HORAS:
000384 930f                          push r16
000385 931f                          push r17
000386 932f                          push r18
                                     
                                     ; cargar valor del contador
000387 9100 011b                     lds r16, contador_horas
                                     
                                     ; calcular decenas (r16 / 10)
000389 e010                          ldi r17, 0          ; inicializar decenas a 0
00038a 300a                          cpi r16, 10         ; comparar con 10
00038b f020                          brlo GUAR_HORA_DIGITOS ; si es menor que 10, saltar
                                 
                                 DECENAS_LOOP_HORA:
00038c 9513                          inc r17             ; incrementar decenas
00038d 500a                          subi r16, 10        ; restar 10
00038e 300a                          cpi r16, 10         ; comparar si quedan ms de 10
00038f f7e4                          brge DECENAS_LOOP_HORA ; si quedan ms de 10, repetir
                                     
                                 GUAR_HORA_DIGITOS:
                                     ; ahora r16 contiene las unidades, r17 contiene las decenas
000390 9300 0118                     sts contador_unidades_hora, r16  ; guardar unidades
000392 9310 0119                     sts contador_decenas_hora, r17   ; guardar decenas
                                     
000394 912f                          pop r18
000395 911f                          pop r17
000396 910f                          pop r16
000397 9508                          ret
                                 
                                 ; actualizar los displays de da basado en contador_dia
                                 ACTUALIZAR_DISPLAYS_DIA:
000398 930f                          push r16
000399 931f                          push r17
00039a 932f                          push r18
                                     
                                     ; cargar valor del contador
00039b 9100 0120                     lds r16, contador_dia
                                     
                                     ; calcular decenas (r16 / 10)
00039d e010                          ldi r17, 0          ; inicializar decenas a 0
00039e 300a                          cpi r16, 10         ; comparar con 10
00039f f020                          brlo GUAR_DIA_DIGITOS ; si es menor que 10, saltar
                                 
                                 DECENAS_LOOP_DIA:
0003a0 9513                          inc r17             ; incrementar decenas
0003a1 500a                          subi r16, 10        ; restar 10
0003a2 300a                          cpi r16, 10         ; comparar si quedan ms de 10
0003a3 f7e4                          brge DECENAS_LOOP_DIA ; si quedan ms de 10, repetir
                                     
                                 GUAR_DIA_DIGITOS:
                                     ; ahora r16 contiene las unidades, r17 contiene las decenas
0003a4 9300 011c                     sts contador_unidades_dia, r16  ; guardar unidades
0003a6 9310 011d                     sts contador_decenas_dia, r17   ; guardar decenas
                                     
0003a8 912f                          pop r18
0003a9 911f                          pop r17
0003aa 910f                          pop r16
0003ab 9508                          ret
                                 
                                 ; actualizar los displays de mes basado en contador_mes
                                 ACTUALIZAR_DISPLAYS_MES:
0003ac 930f                          push r16
0003ad 931f                          push r17
0003ae 932f                          push r18
                                     
                                     ; cargar valor del contador
0003af 9100 0121                     lds r16, contador_mes
                                     
                                     ; calcular decenas (r16 / 10)
0003b1 e010                          ldi r17, 0          ; inicializar decenas a 0
0003b2 300a                          cpi r16, 10         ; comparar con 10
0003b3 f020                          brlo GUAR_MES_DIGITOS ; si es menor que 10, saltar
                                 
                                 DECENAS_LOOP_MES:
0003b4 9513                          inc r17             ; incrementar decenas
0003b5 500a                          subi r16, 10        ; restar 10
0003b6 300a                          cpi r16, 10         ; comparar si quedan ms de 10
0003b7 f7e4                          brge DECENAS_LOOP_MES ; si quedan ms de 10, repetir
                                     
                                 GUAR_MES_DIGITOS:
                                     ; ahora r16 contiene las unidades, r17 contiene las decenas
0003b8 9300 011e                     sts contador_unidades_mes, r16  ; guardar unidades
0003ba 9310 011f                     sts contador_decenas_mes, r17   ; guardar decenas
                                     
0003bc 912f                          pop r18
0003bd 911f                          pop r17
0003be 910f                          pop r16
0003bf 9508                          ret
                                 
                                 ; inicializacin de la tabla de dgitos (patrones de 7 segmentos)
                                 INICIAR_TABLA_DIGITOS:
0003c0 e0f1                          ldi ZH, HIGH(tabla_digitos)
0003c1 e0e0                          ldi ZL, LOW(tabla_digitos)
                                     
0003c2 e30f                          ldi r16, 0b00111111        ; 0
0003c3 9301                          st Z+, r16
0003c4 e006                          ldi r16, 0b00000110        ; 1
0003c5 9301                          st Z+, r16
0003c6 e50b                          ldi r16, 0b01011011        ; 2
0003c7 9301                          st Z+, r16
0003c8 e40f                          ldi r16, 0b01001111        ; 3
0003c9 9301                          st Z+, r16
0003ca e606                          ldi r16, 0b01100110        ; 4
0003cb 9301                          st Z+, r16
0003cc e60d                          ldi r16, 0b01101101        ; 5
0003cd 9301                          st Z+, r16
0003ce e70d                          ldi r16, 0b01111101        ; 6
0003cf 9301                          st Z+, r16
0003d0 e007                          ldi r16, 0b00000111        ; 7
0003d1 9301                          st Z+, r16
0003d2 e70f                          ldi r16, 0b01111111        ; 8
0003d3 9301                          st Z+, r16
0003d4 e60f                          ldi r16, 0b01101111        ; 9
0003d5 9301                          st Z+, r16
                                     
0003d6 9508                          ret
                                 
                                 ; rutina para mostrar los dgitos en los displays segn modo actual
                                 MOSTRAR_DISPLAYS:
                                     ; verificar estado del sistema para determinar qu mostrar
0003d7 9110 0134                     lds r17, estado_sistema
                                     
0003d9 3010                          cpi r17, ESTADO_RELOJ
0003da f049                          breq MOSTRAR_RELOJ_NORMAL
                                     
0003db 3011                          cpi r17, ESTADO_EDICION_RELOJ
0003dc f049                          breq MOSTRAR_RELOJ_EDICION
                                     
0003dd 3012                          cpi r17, ESTADO_FECHA
0003de f069                          breq MOSTRAR_FECHA_NORMAL
                                     
0003df 3013                          cpi r17, ESTADO_EDICION_FECHA
0003e0 f069                          breq MOSTRAR_FECHA_EDICION
                                     
0003e1 3014                          cpi r17, ESTADO_EDICION_ALARMA
0003e2 f089                          breq MOSTRAR_ALARMA_EDICION
                                     
                                     ; si no coincide con ningn estado, mostrar reloj por defecto
0003e3 c000                          rjmp MOSTRAR_RELOJ_NORMAL
                                     
                                 MOSTRAR_RELOJ_NORMAL:
                                     ; en modo reloj normal, siempre mostrar los displays
0003e4 d017                          rcall MOSTRAR_RELOJ
0003e5 9508                          ret
                                     
                                 MOSTRAR_RELOJ_EDICION:
                                     ; en modo edicin de reloj, verificar estado del LED para decidir si mostrar
0003e6 9100 012d                     lds r16, estado_led
0003e8 3000                          cpi r16, 0           ; si estado_led es 0 (apagado), no mostrar displays
0003e9 f081                          breq NO_MOSTRAR_DISPLAYS
                                     
                                     ; mostrar reloj en modo edicin
0003ea d011                          rcall MOSTRAR_RELOJ
0003eb 9508                          ret
                                     
                                 MOSTRAR_FECHA_NORMAL:
                                     ; en modo fecha normal, siempre mostrar los displays
0003ec d02c                          rcall MOSTRAR_FECHA
0003ed 9508                          ret
                                     
                                 MOSTRAR_FECHA_EDICION:
                                     ; en modo edicin de fecha, verificar estado del LED para decidir si mostrar
0003ee 9100 012d                     lds r16, estado_led
0003f0 3000                          cpi r16, 0           ; si estado_led es 0 (apagado), no mostrar displays
0003f1 f041                          breq NO_MOSTRAR_DISPLAYS
                                     
                                     ; mostrar fecha en modo edicin
0003f2 d026                          rcall MOSTRAR_FECHA
0003f3 9508                          ret
                                     
                                 MOSTRAR_ALARMA_EDICION:
                                     ; en modo edicin de alarma, verificar estado del LED para decidir si mostrar
0003f4 9100 012d                     lds r16, estado_led
0003f6 3000                          cpi r16, 0           ; si estado_led es 0 (apagado), no mostrar displays
0003f7 f011                          breq NO_MOSTRAR_DISPLAYS
                                     
                                     ; mostrar alarma en modo edicin
0003f8 d03d                          rcall MOSTRAR_ALARMA
0003f9 9508                          ret
                                     
                                 NO_MOSTRAR_DISPLAYS:
                                     ; asegurarse de que todos los displays estn apagados cuando el LED est apagado
0003fa d058                          rcall APAGAR_TODOS_DISPLAYS
0003fb 9508                          ret
                                 
                                 ; mostrar reloj (horas:minutos)
                                 MOSTRAR_RELOJ:
                                     ; mostrar unidades de minutos
0003fc d056                          rcall APAGAR_TODOS_DISPLAYS
0003fd 9100 0116                     lds r16, contador_unidades_min
0003ff d058                          rcall OBTENER_PATRON
000400 b90b                          out PORTD, r16                   ; cargar patrn de segmentos
000401 9a45                          sbi PORTC, DISPLAY_UNIDADES      ; activar display de unidades
000402 d05c                          rcall DELAY_MULTIPLEX
                                     
                                     ; mostrar decenas de minutos
000403 d04f                          rcall APAGAR_TODOS_DISPLAYS
000404 9100 0117                     lds r16, contador_decenas_min
000406 d051                          rcall OBTENER_PATRON
000407 b90b                          out PORTD, r16                   ; cargar patrn de segmentos
000408 9a44                          sbi PORTC, DISPLAY_DECENAS       ; activar display de decenas
000409 d055                          rcall DELAY_MULTIPLEX
                                     
                                     ; mostrar unidades de hora
00040a d048                          rcall APAGAR_TODOS_DISPLAYS
00040b 9100 0118                     lds r16, contador_unidades_hora
00040d d04a                          rcall OBTENER_PATRON
00040e b90b                          out PORTD, r16                   ; cargar patrn de segmentos
00040f 9a43                          sbi PORTC, DISPLAY_UNIDADES_SUPERIOR ; activar display de unidades hora
000410 d04e                          rcall DELAY_MULTIPLEX
                                     
                                     ; mostrar decenas de hora
000411 d041                          rcall APAGAR_TODOS_DISPLAYS
000412 9100 0119                     lds r16, contador_decenas_hora
000414 d043                          rcall OBTENER_PATRON
000415 b90b                          out PORTD, r16                   ; cargar patrn de segmentos
000416 9a42                          sbi PORTC, DISPLAY_DECENAS_SUPERIOR  ; activar display de decenas hora
000417 d047                          rcall DELAY_MULTIPLEX
                                     
000418 9508                          ret
                                 
                                 ; mostrar fecha (da:mes)
                                 MOSTRAR_FECHA:
                                     ; mostrar unidades de da
000419 d039                          rcall APAGAR_TODOS_DISPLAYS
00041a 9100 011c                     lds r16, contador_unidades_dia
00041c d03b                          rcall OBTENER_PATRON
00041d b90b                          out PORTD, r16                   ; cargar patrn de segmentos
00041e 9a45                          sbi PORTC, DISPLAY_UNIDADES      ; activar display de unidades da
00041f d03f                          rcall DELAY_MULTIPLEX
                                     
                                     ; mostrar decenas de da
000420 d032                          rcall APAGAR_TODOS_DISPLAYS
000421 9100 011d                     lds r16, contador_decenas_dia
000423 d034                          rcall OBTENER_PATRON
000424 b90b                          out PORTD, r16                   ; cargar patrn de segmentos
000425 9a44                          sbi PORTC, DISPLAY_DECENAS       ; activar display de decenas da
000426 d038                          rcall DELAY_MULTIPLEX
                                     
                                     ; mostrar unidades de mes
000427 d02b                          rcall APAGAR_TODOS_DISPLAYS
000428 9100 011e                     lds r16, contador_unidades_mes
00042a d02d                          rcall OBTENER_PATRON
00042b b90b                          out PORTD, r16                   ; cargar patrn de segmentos
00042c 9a43                          sbi PORTC, DISPLAY_UNIDADES_SUPERIOR ; activar display de unidades mes
00042d d031                          rcall DELAY_MULTIPLEX
                                     
                                     ; mostrar decenas de mes
00042e d024                          rcall APAGAR_TODOS_DISPLAYS
00042f 9100 011f                     lds r16, contador_decenas_mes
000431 d026                          rcall OBTENER_PATRON
000432 b90b                          out PORTD, r16                   ; cargar patrn de segmentos
000433 9a42                          sbi PORTC, DISPLAY_DECENAS_SUPERIOR  ; activar display de decenas mes
000434 d02a                          rcall DELAY_MULTIPLEX
                                     
000435 9508                          ret
                                 
                                 ; mostrar alarma (horas:minutos)
                                 MOSTRAR_ALARMA:
                                     ; mostrar unidades de minutos de alarma
000436 d01c                          rcall APAGAR_TODOS_DISPLAYS
000437 9100 0122                     lds r16, alarma_unidades_min
000439 d01e                          rcall OBTENER_PATRON
00043a b90b                          out PORTD, r16                   ; cargar patrn de segmentos
00043b 9a45                          sbi PORTC, DISPLAY_UNIDADES      ; activar display de unidades
00043c d022                          rcall DELAY_MULTIPLEX
                                     
                                     ; mostrar decenas de minutos de alarma
00043d d015                          rcall APAGAR_TODOS_DISPLAYS
00043e 9100 0123                     lds r16, alarma_decenas_min
000440 d017                          rcall OBTENER_PATRON
000441 b90b                          out PORTD, r16                   ; cargar patrn de segmentos
000442 9a44                          sbi PORTC, DISPLAY_DECENAS       ; activar display de decenas
000443 d01b                          rcall DELAY_MULTIPLEX
                                     
                                     ; mostrar unidades de hora de alarma
000444 d00e                          rcall APAGAR_TODOS_DISPLAYS
000445 9100 0124                     lds r16, alarma_unidades_hora
000447 d010                          rcall OBTENER_PATRON
000448 b90b                          out PORTD, r16                   ; cargar patrn de segmentos
000449 9a43                          sbi PORTC, DISPLAY_UNIDADES_SUPERIOR ; activar display de unidades hora
00044a d014                          rcall DELAY_MULTIPLEX
                                     
                                     ; mostrar decenas de hora de alarma
00044b d007                          rcall APAGAR_TODOS_DISPLAYS
00044c 9100 0125                     lds r16, alarma_decenas_hora
00044e d009                          rcall OBTENER_PATRON
00044f b90b                          out PORTD, r16                   ; cargar patrn de segmentos
000450 9a42                          sbi PORTC, DISPLAY_DECENAS_SUPERIOR  ; activar display de decenas hora
000451 d00d                          rcall DELAY_MULTIPLEX
                                     
000452 9508                          ret
                                 
                                 ; apagar todos los displays
                                 APAGAR_TODOS_DISPLAYS:
000453 9845                          cbi PORTC, DISPLAY_UNIDADES
000454 9844                          cbi PORTC, DISPLAY_DECENAS
000455 9843                          cbi PORTC, DISPLAY_UNIDADES_SUPERIOR
000456 9842                          cbi PORTC, DISPLAY_DECENAS_SUPERIOR
000457 9508                          ret
                                 
                                 ; obtener patrn de 7 segmentos para un dgito
                                 OBTENER_PATRON:
000458 e0f1                          ldi ZH, HIGH(tabla_digitos)
000459 e0e0                          ldi ZL, LOW(tabla_digitos)
00045a 0fe0                          add ZL, r16                ; sumar offset
00045b f408                          brcc PC+2                  ; si no hay carry, saltar
00045c 95f3                          inc ZH                     ; si hay carry, incrementar ZH
00045d 8100                          ld r16, Z                  ; cargar patrn desde la tabla
00045e 9508                          ret
                                 
                                 ; pequeo retardo para el multiplexado
                                 DELAY_MULTIPLEX:
00045f e312                          ldi r17, 50
                                 DELAY_LOOP:
000460 951a                          dec r17
000461 f7f1                          brne DELAY_LOOP
000462 9508                          ret
                                 
                                 ; actualiza el estado del LED y displays segn el modo actual
                                 ACTUALIZAR_LED:
                                     ; verificar el estado actual del sistema
000463 9120 0134                     lds r18, estado_sistema
                                     
                                     ; comportamiento segn modo actual
000465 3021                          cpi r18, ESTADO_EDICION_RELOJ
000466 f091                          breq MODO_EDICION
                                     
000467 3023                          cpi r18, ESTADO_EDICION_FECHA
000468 f081                          breq MODO_EDICION
                                     
000469 3024                          cpi r18, ESTADO_EDICION_ALARMA
00046a f071                          breq MODO_EDICION
                                     
                                     ; en modo normal (reloj o fecha): LED parpadea, displays siempre encendidos
00046b 9100 012d                     lds r16, estado_led
00046d 3000                          cpi r16, 0                 ; verificar si el LED est apagado
00046e f029                          breq ENCENDER_LED_NORMAL
                                     
                                     ; apagar solo el LED en modo normal
00046f 9841                          cbi PORTC, LED_INDICADOR
000470 e000                          ldi r16, 0
000471 9300 012d                     sts estado_led, r16
000473 9508                          ret
                                     
                                 ENCENDER_LED_NORMAL:
                                     ; encender solo el LED en modo normal
000474 9a41                          sbi PORTC, LED_INDICADOR
000475 e001                          ldi r16, 1
000476 9300 012d                     sts estado_led, r16
000478 9508                          ret
                                     
                                 MODO_EDICION:
                                     ; en modo edicin: LED y displays parpadean juntos
000479 9100 012d                     lds r16, estado_led
00047b 3000                          cpi r16, 0                 ; verificar si el LED est apagado
00047c f029                          breq ENCENDER_LED_EDICION
                                     
                                     ; apagar LED y establecer displays como apagados
00047d 9841                          cbi PORTC, LED_INDICADOR
00047e e000                          ldi r16, 0
00047f 9300 012d                     sts estado_led, r16
000481 9508                          ret
                                     
                                 ENCENDER_LED_EDICION:
                                     ; encender LED y establecer displays como encendidos
000482 9a41                          sbi PORTC, LED_INDICADOR
000483 e001                          ldi r16, 1
000484 9300 012d                     sts estado_led, r16
000486 9508                          ret
                                 
                                 ; rutina de interrupcin del Timer0
                                 TIMER0_OVF:
000487 930f                          push r16
000488 931f                          push r17
000489 932f                          push r18
00048a b71f                          in r17, SREG
00048b 931f                          push r17
                                     
                                     ; manejar el contador para el parpadeo del LED (cada 500ms)
00048c 9100 012e                     lds r16, contador_parpadeo
00048e 9503                          inc r16
00048f 310e                          cpi r16, 30                ; aproximadamente 500ms (30 desbordamientos)
000490 f421                          brne CHECK_SEGUNDO         ; si no han pasado 500ms, saltar a verificar segundos
                                     
                                     ; ha pasado medio segundo, alternar estado del LED
000491 e000                          ldi r16, 0                 ; reiniciar contador de parpadeo
000492 9300 012e                     sts contador_parpadeo, r16
                                     
                                     ; verificar en qu estado estamos para determinar tipo de parpadeo
000494 dfce                          rcall ACTUALIZAR_LED       ; alternar estado del LED y displays segn modo
                                     
                                 CHECK_SEGUNDO:
000495 9300 012e                     sts contador_parpadeo, r16
                                     
                                     ; verificar estado del sistema - solo no contar si estamos en edicin DE RELOJ O FECHA
000497 9120 0134                     lds r18, estado_sistema
000499 3021                          cpi r18, ESTADO_EDICION_RELOJ
00049a f139                          breq SALIR_TIMER           ; si estamos en modo edicin de reloj, no contar segundos
                                     
00049b 3023                          cpi r18, ESTADO_EDICION_FECHA
00049c f129                          breq SALIR_TIMER           ; si estamos en modo edicin de fecha, no contar segundos
                                     
                                     ; Eliminamos la comprobacin de ESTADO_EDICION_ALARMA para que el reloj siga contando
                                     ; incluso cuando estamos programando la alarma
                                     
                                     ; verificar si la alarma est sonando para incrementar su contador
00049d 9120 0129                     lds r18, alarma_sonando
00049f 3021                          cpi r18, 1
0004a0 f449                          brne CONTINUAR_TIMER       ; si la alarma no est sonando, continuar
                                     
                                     ; la alarma est sonando, incrementar su contador (una vez por segundo)
0004a1 9100 012b                     lds r16, contador_timer
0004a3 330d                          cpi r16, 61                ; verificar si ha pasado un segundo completo
0004a4 f429                          brne CONTINUAR_TIMER       ; si no ha pasado un segundo, no incrementar
                                     
                                     ; ha pasado un segundo, incrementar contador de alarma
0004a5 9120 012a                     lds r18, contador_alarma
0004a7 9523                          inc r18
0004a8 9320 012a                     sts contador_alarma, r18
                                     
                                 CONTINUAR_TIMER:
                                     ; contar segundos incluso en modo fecha y alarma (cuenta en segundo plano)
                                     ; incrementar contador para medir 1 segundo
0004aa 9100 012b                     lds r16, contador_timer
0004ac 9503                          inc r16
                                     
                                     ; verificar si ha pasado 1 segundo (aprox. 61 desbordamientos con preescalador 1024)
0004ad 330d                          cpi r16, 61
0004ae f489                          brne GUARDAR_TIMER         ; si no han pasado 61 desbordamientos, guardar y salir
                                     
                                     ; ha pasado 1 segundo
0004af e000                          ldi r16, 0                 ; reiniciar contador del timer
0004b0 9300 012b                     sts contador_timer, r16
                                     
                                     ; incrementar contador de segundos
0004b2 9100 012c                     lds r16, contador_segundos
0004b4 9503                          inc r16
                                     
                                     ; verificar si han pasado 60 segundos
0004b5 330c                          cpi r16, 60
0004b6 f431                          brne GUARDAR_SEGUNDOS      ; si no han pasado 60 segundos, guardar y salir
                                     
                                     ; ha pasado 1 minuto completo
0004b7 e000                          ldi r16, 0                 ; reiniciar contador de segundos
0004b8 9300 012c                     sts contador_segundos, r16
                                     
                                     ; incrementar minutos y verificar cambio de da
0004ba d02d                          rcall INCREMENTAR_TIEMPO_AUTO
                                     
                                     ; verificar si coincide con la hora de alarma
0004bb d00c                          rcall VERIFICAR_ALARMA
                                     
0004bc c005                          rjmp SALIR_TIMER
                                     
                                 GUARDAR_SEGUNDOS:
0004bd 9300 012c                     sts contador_segundos, r16
0004bf c002                          rjmp SALIR_TIMER
                                     
                                 GUARDAR_TIMER:
0004c0 9300 012b                     sts contador_timer, r16
                                     
                                 SALIR_TIMER:
0004c2 911f                          pop r17
0004c3 bf1f                          out SREG, r17
0004c4 912f                          pop r18
0004c5 911f                          pop r17
0004c6 910f                          pop r16
0004c7 9518                          reti
                                 
                                 ; verificar si la hora actual coincide con la hora de alarma
                                 VERIFICAR_ALARMA:
0004c8 930f                          push r16
0004c9 931f                          push r17
                                     
                                     ; verificar si la alarma est activa
0004ca 9100 0128                     lds r16, alarma_activa
0004cc 3000                          cpi r16, 0
0004cd f0b9                          breq SALIR_VERIFICAR_ALARMA_HORA  ; si la alarma no est activa, salir
                                     
                                     ; verificar si la alarma ya est sonando
0004ce 9100 0129                     lds r16, alarma_sonando
0004d0 3001                          cpi r16, 1
0004d1 f099                          breq SALIR_VERIFICAR_ALARMA_HORA  ; si ya est sonando, salir
                                     
                                     ; comparar horas
0004d2 9100 011b                     lds r16, contador_horas
0004d4 9110 0127                     lds r17, alarma_horas
0004d6 1701                          cp r16, r17
0004d7 f469                          brne SALIR_VERIFICAR_ALARMA_HORA  ; si las horas no coinciden, salir
                                     
                                     ; comparar minutos
0004d8 9100 011a                     lds r16, contador_minutos
0004da 9110 0126                     lds r17, alarma_minutos
0004dc 1701                          cp r16, r17
0004dd f439                          brne SALIR_VERIFICAR_ALARMA_HORA  ; si los minutos no coinciden, salir
                                     
                                     ; la hora actual coincide con la hora de alarma, activar alarma
0004de e001                          ldi r16, 1
0004df 9300 0129                     sts alarma_sonando, r16    ; indicar que la alarma est sonando
                                     
                                     ; inicializar contador de tiempo de alarma
0004e1 e000                          ldi r16, 0
0004e2 9300 012a                     sts contador_alarma, r16
                                     
                                     ; activar pin de alarma en PC0
0004e4 9a40                          sbi PORTC, PIN_ALARMA
                                     
                                 SALIR_VERIFICAR_ALARMA_HORA:
0004e5 911f                          pop r17
0004e6 910f                          pop r16
0004e7 9508                          ret
                                 
                                 ; incrementar automticamente los minutos (modo reloj) y verificar cambio de da
                                 INCREMENTAR_TIEMPO_AUTO:
0004e8 930f                          push r16
0004e9 931f                          push r17
0004ea 932f                          push r18
                                     
                                     ; cargar el valor actual del contador de minutos
0004eb 9100 011a                     lds r16, contador_minutos
                                     
                                     ; incrementar el contador de minutos
0004ed 9503                          inc r16
0004ee 330c                          cpi r16, 60              ; verificar si lleg a 60
0004ef f491                          brne GUARDAR_MIN_AUTO_T
                                     
                                     ; si lleg a 60, reiniciar a 0 y aumentar una hora
0004f0 e000                          ldi r16, 0
0004f1 9300 011a                     sts contador_minutos, r16
                                     
                                     ; incrementar una hora
0004f3 9100 011b                     lds r16, contador_horas
0004f5 9503                          inc r16
0004f6 3108                          cpi r16, 24              ; verificar si lleg a 24 horas
0004f7 f421                          brne GUARDAR_HORA_AUTO_T
                                     
                                     ; si lleg a 24 horas (medianoche), reiniciar a 0 y avanzar un da
0004f8 e000                          ldi r16, 0
0004f9 9300 011b                     sts contador_horas, r16
                                     
                                     ; incrementar fecha al cambiar de da
0004fb d010                          rcall AVANZAR_DIA_AUTO
                                     
                                 GUARDAR_HORA_AUTO_T:
0004fc 9300 011b                     sts contador_horas, r16
                                     
                                     ; actualizar displays de horas
0004fe de85                          rcall ACTUALIZAR_DISPLAYS_HORAS
                                     
                                     ; continuar con la actualizacin de minutos
0004ff e000                          ldi r16, 0               ; minutos = 0 (si venimos de incrementar horas)
000500 330c                          cpi r16, 60              ; verificar si incrementamos horas
000501 f439                          brne GUARDAR_MIN_ORIGINAL ; si no incrementamos horas, mantener el valor original
                                     
                                 GUARDAR_MIN_AUTO_T:
000502 9300 011a                     sts contador_minutos, r16
                                     
                                     ; actualizar displays de minutos
000504 de6b                          rcall ACTUALIZAR_DISPLAYS_MINUTOS
                                     
000505 912f                          pop r18
000506 911f                          pop r17
000507 910f                          pop r16
000508 9508                          ret
                                     
                                 GUARDAR_MIN_ORIGINAL:
000509 9100 011a                     lds r16, contador_minutos  ; restaurar valor original de minutos
00050b cff6                          rjmp GUARDAR_MIN_AUTO_T
                                 
                                 ; incrementar automticamente el da al cambiar de da (medianoche)
                                 AVANZAR_DIA_AUTO:
00050c 930f                          push r16
00050d 931f                          push r17
00050e 932f                          push r18
                                     
                                     ; obtener valor actual del da
00050f 9100 0120                     lds r16, contador_dia
                                     
                                     ; incrementar contador
000511 9503                          inc r16
                                     
                                     ; obtener lmite mximo de das para el mes actual
000512 9110 0121                     lds r17, contador_mes     ; cargar mes actual en r17
000514 2f20                          mov r18, r16              ; guardar da incrementado en r18
000515 2f01                          mov r16, r17              ; mover mes a r16 para funcin
000516 ddef                          rcall OBTENER_DIAS_MES    ; r16 ahora contiene das mximos
000517 2f10                          mov r17, r16              ; das mximos en r17
000518 2f02                          mov r16, r18              ; restaurar da incrementado en r16
                                     
                                     ; verificar si excedi el lmite
000519 1701                          cp r16, r17
00051a f080                          brlo DIA_AUTO_NORMAL      ; si da < das mximos, guardar
00051b 1710                          cp r17, r16
00051c f071                          breq DIA_AUTO_NORMAL      ; si da == das mximos, guardar
                                     
                                     ; si excedi el lmite, reset a da 1 e incrementar mes
00051d e001                          ldi r16, 1
00051e 9300 0120                     sts contador_dia, r16
                                     
                                     ; incrementar mes
000520 9100 0121                     lds r16, contador_mes
000522 9503                          inc r16
                                     
                                     ; verificar lmite de mes (1-12)
000523 300d                          cpi r16, 13
000524 f008                          brlo MES_AUTO_NORMAL
                                     
                                     ; si lleg a 13, volver a mes 1 (enero)
000525 e001                          ldi r16, 1
                                     
                                 MES_AUTO_NORMAL:
000526 9300 0121                     sts contador_mes, r16
                                     
                                     ; actualizar displays de mes
000528 de83                          rcall ACTUALIZAR_DISPLAYS_MES
                                     
                                     ; actualizar displays de da (siempre, incluso si no cambi el da)
000529 de6e                          rcall ACTUALIZAR_DISPLAYS_DIA
00052a c003                          rjmp FIN_DIA_AUTO
                                     
                                 DIA_AUTO_NORMAL:
00052b 9300 0120                     sts contador_dia, r16
                                     
                                     ; actualizar dgitos para mostrar en display
00052d de6a                          rcall ACTUALIZAR_DISPLAYS_DIA
                                 
                                 FIN_DIA_AUTO:
00052e 912f                          pop r18
00052f 911f                          pop r17
000530 910f                          pop r16


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega328P" register use summary:
x  :   0 y  :   0 z  :  24 r0 :   0 r1 :   0 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16: 433 r17: 264 r18:  44 r19:   0 r20:   0 
r21:   0 r22:   0 r23:   0 r24:   0 r25:   0 r26:   0 r27:   0 r28:   0 
r29:   0 r30:   6 r31:   6 
Registers used: 6 out of 35 (17.1%)

"ATmega328P" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :   2 adiw  :   0 and   :   0 
andi  :   0 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   2 brcs  :   0 break :   0 breq  :  34 brge  :   6 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  16 brlt  :   0 brmi  :   0 
brne  :  39 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :  11 cbr   :   0 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :   0 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :   8 cpc   :   0 
cpi   :  86 cpse  :   0 dec   :   8 eor   :   0 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :   9 inc   :  22 jmp   :   0 
ld    :   2 ldd   :   0 ldi   : 127 lds   :  91 lpm   :   0 lsl   :   0 
lsr   :   0 mov   :  11 movw  :   0 mul   :   0 muls  :   0 mulsu :   0 
neg   :   0 nop   :   0 or    :   0 ori   :   2 out   :  21 pop   :  77 
push  :  77 rcall :  97 ret   :  49 reti  :   1 rjmp  :  76 rol   :   0 
ror   :   0 sbc   :   0 sbci  :   0 sbi   :  17 sbic  :   0 sbis  :   0 
sbiw  :   0 sbr   :   0 sbrc  :  17 sbrs  :  17 sec   :   0 seh   :   0 
sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   0 st    :  22 std   :   0 sts   : 127 
sub   :   0 subi  :   6 swap  :   0 tst   :   0 wdr   :   0 
Instructions used: 31 out of 113 (27.4%)

"ATmega328P" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000a64   2598      0   2598   32768   7.9%
[.dseg] 0x000100 0x000135      0     53     53    2048   2.6%
[.eseg] 0x000000 0x000000      0      0      0    1024   0.0%

Assembly complete, 0 errors, 0 warnings
